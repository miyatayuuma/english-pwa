<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>è‹±èªå­¦ç¿’ï¼ˆç¯„å›²UIï¼‹ASRãƒ»å®‰å®šæ”¹è‰¯ç‰ˆï¼‰</title>
  <!-- â˜… PWA è¿½åŠ  -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b0e1a" />
  <style>
    :root{ --bg:#0b0e1a; --panel:rgba(20,24,36,.65); --bd:rgba(255,255,255,.12); --txt:#e6e8ef; --muted:#aeb5c6; --accent:#62d5ff; --good:#46d37f; --bad:#ff6b6b; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,"Segoe UI","Noto Sans JP",sans-serif}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    #loadingOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(120% 120% at 50% 45%,rgba(40,54,94,.88),rgba(11,14,26,.96));z-index:100000;transition:opacity .6s ease,visibility .6s ease;opacity:1;visibility:visible;pointer-events:auto}
    #loadingOverlay.hidden{opacity:0;visibility:hidden;pointer-events:none}
    #loadingOverlay .loaderAura{position:relative;width:120px;height:120px;display:flex;align-items:center;justify-content:center}
    #loadingOverlay .loaderCore{width:78px;height:78px;border-radius:999px;background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.55),rgba(98,213,255,.25) 45%,rgba(11,14,26,0) 75%);box-shadow:0 0 32px rgba(98,213,255,.35);animation:loaderSpin 3.8s linear infinite;filter:blur(.3px)}
    #loadingOverlay .loaderRing{position:absolute;width:108px;height:108px;border-radius:999px;border:1px solid rgba(255,255,255,.12);animation:loaderPulse 2.6s ease-in-out infinite}
    #loadingOverlay .loaderDots{position:absolute;bottom:-32px;display:flex;gap:12px}
    #loadingOverlay .loaderDots span{width:10px;height:10px;border-radius:999px;background:rgba(255,255,255,.28);animation:loaderDots 1.2s ease-in-out infinite}
    #loadingOverlay .loaderDots span:nth-child(2){animation-delay:.15s}
    #loadingOverlay .loaderDots span:nth-child(3){animation-delay:.3s}
    @keyframes loaderSpin{0%{transform:rotate(0deg);}50%{transform:rotate(180deg) scale(1.04);}100%{transform:rotate(360deg);}}
    @keyframes loaderPulse{0%{transform:scale(.92);opacity:.65;}50%{transform:scale(1.08);opacity:1;}100%{transform:scale(.92);opacity:.65;}}
    @keyframes loaderDots{0%,100%{transform:translateY(0);opacity:.35;}50%{transform:translateY(-6px);opacity:1;}}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto auto 1fr auto}

    header{padding:10px 12px;display:flex;gap:14px;align-items:center;background:var(--panel);border-bottom:1px solid var(--bd)}
    .stat{display:flex;gap:4px;align-items:center;font-size:14px;color:var(--muted)}
    .stat-main{color:var(--txt);font-size:18px;font-weight:600;font-variant-numeric:tabular-nums}
    .stat-sub{color:var(--muted);font-size:14px;font-weight:500;letter-spacing:.02em}
    .grow{flex:1}
    .icon{width:38px;height:38px;border-radius:999px;border:1px solid var(--bd);display:grid;place-items:center;cursor:pointer;background:#111726}

    /* ç¯„å›²UIï¼ˆãƒã‚¤ãƒ†ã‚£ãƒ–ã‚»ãƒ¬ã‚¯ãƒˆä¸­å¿ƒï¼ãƒ¢ãƒã‚¤ãƒ«æœ€é©ï¼‰ */
    #rangeBar{display:grid;grid-template-columns:minmax(96px,clamp(108px,22vw,164px)) minmax(0,1fr);grid-template-rows:repeat(2,auto);gap:8px 14px;align-items:stretch;padding:8px 12px;background:rgba(20,24,36,.5);border-bottom:1px solid rgba(255,255,255,.12)}
    #rangeBar .range-item{display:flex;flex-direction:column;gap:4px;min-width:0}
    #rangeBar .range-item select{width:100%}
    #rangeBar .range-level{justify-content:center}
    #rangeBar .range-search{justify-content:center}
    select, .switch{background:#111726;border:1px solid var(--bd);color:var(--txt);border-radius:12px;padding:7px 8px}
    #rangeBar select{width:100%}
    #rangeBar .search-input{display:flex;align-items:center;height:100%;background:#111726;border:1px solid var(--bd);border-radius:12px;padding:0 8px;min-height:38px;flex:1 1 auto;width:100%}
    #rangeBar .search-input input{background:transparent;border:none;color:var(--txt);font-size:14px;padding:8px 4px;min-width:0;width:100%;flex:1}
    #rangeBar .search-input input::placeholder{color:var(--muted)}
    #rangeBar .search-input input:focus{outline:none}
    #rangeBar .search-input input::-webkit-search-cancel-button{filter:invert(80%)}
    .switch{display:flex;gap:8px;align-items:center}
    .level-filter{display:flex;align-items:center;gap:6px;padding:6px 8px;border-radius:12px;border:1px solid var(--bd);background:#111726;flex-wrap:nowrap;justify-content:flex-start;width:100%;min-height:36px}
    .level-filter-label{font-size:12px;color:var(--muted);letter-spacing:.03em;white-space:nowrap}
    .level-filter-buttons{display:flex;gap:3px;flex-wrap:nowrap;flex:1;justify-content:flex-end}
    .level-chip{min-width:26px;height:26px;border-radius:8px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:var(--txt);font-size:12px;font-weight:600;cursor:pointer;transition:all .18s ease;padding:0 8px;display:flex;align-items:center;justify-content:center;flex:1 1 36px}
    .level-chip.active{background:var(--accent);color:#041019;border-color:rgba(98,213,255,.82);box-shadow:0 0 0 1px rgba(98,213,255,.32)}
    .level-chip:focus-visible{outline:2px solid var(--accent);outline-offset:2px}

    main{padding:12px;overflow:auto}
    .card{max-width:840px;margin:0 auto;background:var(--panel);border:1px solid var(--bd);border-radius:18px;padding:16px;min-height:50vh;display:flex;flex-direction:column;gap:12px;touch-action:manipulation}
    .chips{display:flex;gap:6px;flex-wrap:wrap}
    .en{font-size:22px;line-height:1.6;word-break:normal;overflow-wrap:break-word;white-space:normal}
    .en.concealed{display:flex;align-items:center;justify-content:center;min-height:120px;color:var(--muted);font-size:18px;font-style:italic;text-align:center}
    .hint-placeholder{opacity:.7}
    .en .tok{padding:0 2px;border-radius:4px}
    .en .hit{background:rgba(70,211,127,.18);border-bottom:1px solid rgba(70,211,127,.6)}
    .en .miss{background:rgba(255,107,107,.15);border-bottom:1px dashed rgba(255,107,107,.7)}
    .ja{font-size:16px;color:var(--muted);display:none}
    #transcript{min-height:1.6em}
    #transcript .interim{opacity:.6}

    .kpi{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:12px;flex-wrap:wrap}
    .kpi .val{color:var(--txt);font-weight:600}
    .match-val{font-size:18px;transition:color .3s ease}
    .match-good{color:var(--good)}
    .match-mid{color:#f6c863}
    .match-bad{color:var(--bad)}
    .attempt-info{font-size:12px;color:var(--muted);transition:color .3s ease}
    .attempt-info.alert{color:var(--bad)}

    footer{border-top:1px solid var(--bd);padding:8px 12px;display:flex;gap:10px;align-items:center;background:var(--panel)}
    progress{width:160px;height:10px}
    .btn{border:1px solid var(--bd);border-radius:12px;background:#111726;color:var(--txt);padding:10px 14px;cursor:pointer}
    .btn.ok{background:#10331f;border-color:#1f5c38}
    .audio-ctrls{display:flex;gap:14px;justify-content:center;align-items:center;margin-top:8px;flex-wrap:wrap}
    #btnPlay{width:60px;height:60px;font-size:22px;border-radius:999px;background:#162032;border-color:#2a3753;display:grid;place-items:center;font-weight:600;transition:transform .2s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease}
    #btnPlay:disabled{opacity:.35;cursor:not-allowed;box-shadow:none}
    #btnPlay.playing{background:#235179;border-color:#58a3d9;box-shadow:0 0 0 0 rgba(88,163,217,.45);animation:playPulse 1.6s ease-in-out infinite}
    #btnMic{width:72px;height:72px;font-size:22px;border-radius:999px;background:#1a2134;border-color:#2a3753;display:grid;place-items:center;font-weight:600;transition:transform .2s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease}
    #btnMic.recording{background:var(--accent);border-color:#7de4ff;box-shadow:0 0 0 0 rgba(98,213,255,.55);animation:micPulse 1.4s ease-in-out infinite}
    #btnMic:disabled{opacity:.35;cursor:not-allowed;animation:none;box-shadow:none}
    #btnMic .micIcon{font-size:28px}
    .speed-ctrl{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(17,23,38,.65);border:1px solid rgba(255,255,255,.08);box-shadow:inset 0 0 0 1px rgba(0,0,0,.35)}
    .speed-btn{width:32px;height:32px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#131b2d;color:var(--txt);display:grid;place-items:center;cursor:pointer;font-size:16px;transition:transform .18s ease, background .18s ease, border-color .18s ease}
    .speed-btn:active{transform:scale(.92)}
    .speed-btn:focus-visible{outline:2px solid var(--accent);outline-offset:2px}
    .speed-btn:hover{background:#1a2337;border-color:rgba(255,255,255,.24)}
    .speed-slider{appearance:none;-webkit-appearance:none;width:120px;height:4px;border-radius:999px;background:linear-gradient(90deg,rgba(98,213,255,.65),rgba(98,213,255,.18));position:relative}
    .speed-slider::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#62d5ff;border:2px solid rgba(10,16,29,.75);box-shadow:0 0 8px rgba(98,213,255,.55);cursor:pointer}
    .speed-slider::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#62d5ff;border:2px solid rgba(10,16,29,.75);box-shadow:0 0 8px rgba(98,213,255,.55);cursor:pointer}
    .speed-slider::-moz-range-track{height:4px;border-radius:999px;background:linear-gradient(90deg,rgba(98,213,255,.65),rgba(98,213,255,.18))}
    .speed-slider:focus-visible{outline:none;box-shadow:0 0 0 2px rgba(98,213,255,.4)}
    .speed-bubble{min-width:44px;text-align:center;font-size:13px;color:var(--txt);font-variant-numeric:tabular-nums}
    @media (max-width:680px){
      #rangeBar{grid-template-columns:minmax(94px,clamp(104px,32vw,168px)) minmax(0,1fr);gap:8px 12px}
      #levelFilter{padding:6px 8px}
    }
    @media (max-width:480px){
      #rangeBar{grid-template-columns:minmax(92px,36%) minmax(0,1fr)}
      #levelFilter{padding:6px 7px}
      #rangeBar .search-input{padding:0 8px}
    }
    @media (max-width:520px){
      .speed-ctrl{order:3;width:100%;justify-content:center}
      .speed-slider{width:100px}
    }
    @keyframes playPulse{0%{transform:scale(1);box-shadow:0 0 0 0 rgba(88,163,217,.45);}70%{transform:scale(1.05);box-shadow:0 0 0 16px rgba(88,163,217,0);}100%{transform:scale(1);box-shadow:0 0 0 0 rgba(88,163,217,0);}}
    @keyframes micPulse{0%{transform:scale(1);box-shadow:0 0 0 0 rgba(98,213,255,.55);}70%{transform:scale(1.05);box-shadow:0 0 0 16px rgba(98,213,255,0);}100%{transform:scale(1);box-shadow:0 0 0 0 rgba(98,213,255,0);}}
    .next-cta{margin-top:10px;display:block;width:100%;font-size:18px;padding:14px;border-radius:14px;background:#10331f;border-color:#1f5c38;font-weight:600}

    /* è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */
    #cfgModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:9999}
    #cfgBox{width:min(560px,92%);background:#111726;border:1px solid var(--bd);border-radius:14px;padding:16px}
    #cfgBox h3{margin:0 0 8px 0}
    #cfgBox label{display:block;margin:10px 0}
    #cfgBox input[type="text"], #cfgBox input[type="url"]{width:100%;padding:8px;border-radius:10px;border:1px solid var(--bd);background:#0c1221;color:var(--txt)}
    #cfgBox .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    #toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#0f1422;border:1px solid #24304a;color:#b7c0d6;border-radius:10px;padding:8px 12px;z-index:99999;display:none}
    #dirPermOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:24px;background:rgba(11,14,26,.88);z-index:100002}
    #dirPermOverlay.show{display:flex}
    #dirPermBox{max-width:420px;width:100%;background:#111726;border:1px solid var(--bd);border-radius:18px;padding:20px;box-shadow:0 24px 60px rgba(0,0,0,.5)}
    #dirPermBox h2{margin:0 0 12px 0;font-size:20px}
    #dirPermBox p{margin:0 0 12px 0;line-height:1.6;color:var(--muted)}
    #dirPermStatus{min-height:1.2em;font-size:13px;color:var(--bad);margin-bottom:12px}
    #dirPermBox .actions{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}
  </style>
</head>
<body>
<div id="loadingOverlay" role="presentation" aria-hidden="true">
  <div class="loaderAura">
    <div class="loaderRing"></div>
    <div class="loaderCore"></div>
    <div class="loaderDots" aria-hidden="true"><span></span><span></span><span></span></div>
  </div>
</div>
<div id="dirPermOverlay" hidden aria-hidden="true">
  <div id="dirPermBox" role="dialog" aria-modal="true" aria-labelledby="dirPermTitle">
    <h2 id="dirPermTitle">éŸ³å£°ãƒ•ã‚©ãƒ«ãƒ€ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™</h2>
    <p>ä¿å­˜æ¸ˆã¿ã®éŸ³å£°ãƒ•ã‚©ãƒ«ãƒ€ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€ç«¯æœ«ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€Œè¨±å¯ã™ã‚‹ã€ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ãªã„å ´åˆã€éŸ³å£°ãŒå†ç”Ÿã§ããªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</p>
    <div id="dirPermStatus" aria-live="polite"></div>
    <div class="actions">
      <button id="dirPermLater" class="btn" hidden>è¨±å¯ã›ãšç¶šè¡Œ</button>
      <button id="dirPermAllow" class="btn ok">è¨±å¯ã‚’é–‹ã</button>
    </div>
  </div>
</div>
<div id="app">
  <header>
    <div class="stat">
      <span class="stat-main" id="statSection">â€”</span>
    </div>
    <div class="stat">
      <span class="stat-sub">Lv</span>
      <span class="stat-main" id="statLevelAvg">â€”</span>
    </div>
    <div class="stat">
      <span class="stat-main" id="statProgressCurrent">0</span>
      <span class="stat-sub">/</span>
      <span class="stat-main" id="statProgressTotal">0</span>
    </div>
    <div class="grow"></div>
    <div id="btnCfg" class="icon" title="è¨­å®š">âš™ï¸</div>
  </header>

  <!-- å‡ºé¡Œç¯„å›²ï¼ˆãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ”ãƒƒã‚«ãƒ¼ï¼‰ -->
  <div id="rangeBar">
    <div class="range-item range-sec">
      <label class="sr-only" for="secSel">ã‚»ã‚¯ã‚·ãƒ§ãƒ³</label>
      <select id="secSel" aria-label="ã‚»ã‚¯ã‚·ãƒ§ãƒ³é¸æŠ"></select>
    </div>
    <div class="range-item range-level">
      <div id="levelFilter" class="level-filter" role="group" aria-label="ãƒ¬ãƒ™ãƒ«é¸æŠ"></div>
    </div>
    <div class="range-item range-order">
      <label class="sr-only" for="orderSel">ä¸¦ã³</label>
      <select id="orderSel" aria-label="ä¸¦ã³é †">
        <option value="asc">æ˜‡é †</option>
        <option value="rnd">ãƒ©ãƒ³ãƒ€ãƒ </option>
      </select>
    </div>
    <div class="range-item range-search">
      <label class="search-input" for="rangeSearch">
        <span class="sr-only">å˜èªæ¤œç´¢</span>
        <input id="rangeSearch" type="search" placeholder="å˜èªæ¤œç´¢" autocomplete="off" />
      </label>
    </div>
  </div>

  <main>
    <section class="card" id="card" aria-live="polite">
      <div class="chips" id="chips"></div>
      <div id="enText" class="en">å‡ºé¡Œã‚’æº–å‚™ã—ã¦ã„ã¾ã™â€¦ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§å’Œè¨³ï¼‰</div>
      <div id="jaText" class="ja">â€”</div>
      <div id="transcript" class="muted"></div>

      <div class="kpi">
        <div>ä¸€è‡´ç‡ <span class="val match-val" id="valMatch">â€”</span></div>
        <div>Lv <span class="val" id="valLevel">â€”</span></div>
        <div id="attemptInfo" class="attempt-info"></div>
      </div>

      <div class="audio-ctrls">
        <button id="btnPlay" class="btn" type="button" aria-label="éŸ³å£°ã‚’å†ç”Ÿ/ä¸€æ™‚åœæ­¢"><span class="playIcon">â–¶ï¸</span></button>
        <button id="btnMic" class="btn" type="button" aria-label="ãƒã‚¤ã‚¯é–‹å§‹/åœæ­¢"><span class="micIcon">ğŸ¤</span></button>
        <div class="speed-ctrl" role="group" aria-labelledby="speedLabel">
          <span id="speedLabel" class="sr-only">å†ç”Ÿé€Ÿåº¦</span>
          <button id="speedDown" class="speed-btn" type="button" aria-label="å†ç”Ÿé€Ÿåº¦ã‚’ä¸‹ã’ã‚‹"><span aria-hidden="true">ğŸ¢</span></button>
          <input id="speedSlider" class="speed-slider" type="range" min="0.5" max="1.5" step="0.05" value="1" aria-labelledby="speedLabel">
          <button id="speedUp" class="speed-btn" type="button" aria-label="å†ç”Ÿé€Ÿåº¦ã‚’ä¸Šã’ã‚‹"><span aria-hidden="true">ğŸ‡</span></button>
          <span class="speed-bubble" id="speedValue" aria-live="polite">1.0Ã—</span>
        </div>
      </div>
      <button id="btnNext" class="btn next-cta" type="button" hidden>æ¬¡ã¸</button>
    </section>
  </main>

  <footer>
    <progress id="pbar" value="0" max="1"></progress>
    <span id="footerInfo" class="muted">å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šæˆ»ã‚‹/é€²ã‚€ã€€ä¸Šï¼šãƒ’ãƒ³ãƒˆï¼ˆè‹±æ–‡â†’å’Œè¨³ï¼‰</span>
    <div class="grow"></div>
  </footer>
</div>

<audio id="player" preload="auto" crossorigin="anonymous"></audio>
<div id="toast"></div>

<!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="cfgModal">
  <div id="cfgBox">
    <h3>æ¥ç¶šè¨­å®š</h3>
    <label>GAS Web App URLï¼ˆ/execï¼‰
      <input id="cfgUrl" type="url" placeholder="https://script.google.com/macros/s/.../exec">
    </label>
    <label>API Keyï¼ˆæœªè¨­å®šã§ã‚‚å¯ï¼‰
      <input id="cfgKey" type="text" placeholder="ï¼ˆç©ºã§ã‚‚å¯ï¼‰">
    </label>
    <label>éŸ³æºãƒ™ãƒ¼ã‚¹URLï¼ˆä¾‹: https://example.com/audio ã¾ãŸã¯ ./audioï¼‰
      <input id="cfgAudioBase" type="text" placeholder="./audio">
    </label>
    <div class="row" style="margin-top:8px">
      <button id="btnPickDir" class="btn">éŸ³æºãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒ‡å®šï¼ˆãƒ•ã‚©ãƒ«ãƒ€ãƒ”ãƒƒã‚«ãƒ¼ï¼‰</button>
      <button id="btnClearDir" class="btn">ãƒ•ã‚©ãƒ«ãƒ€è§£é™¤</button>
      <span id="dirStatus" class="muted" style="font-size:12px"></span>
    </div>
    <div class="row" style="margin-top:8px">
      <input id="filePick" type="file" accept="audio/*" multiple style="display:none">
      <button id="btnImport" class="btn">éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’OPFSã¸å–ã‚Šè¾¼ã¿</button>
      <button id="btnTestAudio" class="btn">ãƒ†ã‚¹ãƒˆå†ç”Ÿ</button>
      <div class="grow"></div>
      <button id="cfgClose" class="btn">é–‰ã˜ã‚‹</button>
      <button id="cfgSave" class="btn" style="background:#1a2134;border-color:#233252">ä¿å­˜</button>
    </div>
    <div class="row" style="margin-top:12px">
      <button id="btnNotifPerm" class="btn">å­¦ç¿’ãƒªãƒã‚¤ãƒ³ãƒ‰é€šçŸ¥ã‚’æœ‰åŠ¹åŒ–</button>
      <span id="notifStatus" class="muted" style="font-size:12px"></span>
    </div>
  </div>
</div>

<script>
(function(){
  // ===== Utilities =====
  const qs=(s,el=document)=>el.querySelector(s);
  const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
  const now=()=>Date.now(); const UA=(()=>navigator.userAgent||'')();
  const CONTRACTION_PATTERNS=[
    {seq:['i','m'], out:'im'},
    {seq:['i','d'], out:'id'},
    {seq:['i','ll'], out:'ill'},
    {seq:['i','ve'], out:'ive'},
    {seq:['you','re'], out:'youre'},
    {seq:['you','ve'], out:'youve'},
    {seq:['you','ll'], out:'youll'},
    {seq:['you','d'], out:'youd'},
    {seq:['he','s'], out:'hes'},
    {seq:['she','s'], out:'shes'},
    {seq:['it','s'], out:'its'},
    {seq:['we','re'], out:'were'},
    {seq:['we','ve'], out:'weve'},
    {seq:['we','ll'], out:'well'},
    {seq:['we','d'], out:'wed'},
    {seq:['they','re'], out:'theyre'},
    {seq:['they','ve'], out:'theyve'},
    {seq:['they','ll'], out:'theyll'},
    {seq:['they','d'], out:'theyd'},
    {seq:['that','s'], out:'thats'},
    {seq:['there','s'], out:'theres'},
    {seq:['here','s'], out:'heres'},
    {seq:['who','s'], out:'whos'},
    {seq:['what','s'], out:'whats'},
    {seq:['where','s'], out:'wheres'},
    {seq:['when','s'], out:'whens'},
    {seq:['why','s'], out:'whys'},
    {seq:['how','s'], out:'hows'},
    {seq:['let','s'], out:'lets'}
  ];
  const NUMBER_WORD_MAP=new Map(Object.entries({
    zero:'0', one:'1', two:'2', three:'3', four:'4', five:'5', six:'6', seven:'7', eight:'8', nine:'9',
    ten:'10', eleven:'11', twelve:'12', thirteen:'13', fourteen:'14', fifteen:'15', sixteen:'16', seventeen:'17', eighteen:'18', nineteen:'19',
    twenty:'20', thirty:'30', forty:'40', fifty:'50', sixty:'60', seventy:'70', eighty:'80', ninety:'90',
    hundred:'100', thousand:'1000', million:'1000000', billion:'1000000000'
  }));
  const CURRENCY_MAP=new Map([
    ['dollar','usd'], ['dollars','usd'], ['usd','usd']
  ]);
  const UNIT_MAP=new Map([
    ['degrees','degree'], ['degree','degree'],
    ['celsius','celsius']
  ]);

  function mergeContractions(tokens){
    if(!tokens.length) return tokens;
    const out=[];
    for(let i=0;i<tokens.length;){
      let matched=false;
      for(const {seq,out:outToken} of CONTRACTION_PATTERNS){
        if(i+seq.length>tokens.length) continue;
        let ok=true;
        for(let j=0;j<seq.length;j++){
          if(tokens[i+j]!==seq[j]){ ok=false; break; }
        }
        if(ok){
          out.push(outToken);
          i+=seq.length;
          matched=true;
          break;
        }
      }
      if(matched) continue;
      out.push(tokens[i]);
      i++;
    }
    return out;
  }

  function canonicalizeToken(token){
    if(!token) return '';
    const digits=token.replace(/[,]/g,'');
    if(/^[+-]?\d+(?:\.\d+)?$/.test(digits)){
      return digits.replace(/^\+/, '');
    }
    const num=NUMBER_WORD_MAP.get(token);
    if(num) return num;
    const unit=UNIT_MAP.get(token);
    if(unit) return unit;
    const curr=CURRENCY_MAP.get(token);
    if(curr) return curr;
    return token;
  }

  function canonicalTokens(input){
    if(!input) return [];
    let text=(input||'').toLowerCase().normalize('NFKC');
    text=text.replace(/â„ƒ/g,' degree celsius ');
    text=text.replace(/Â°\s*c/g,' degree celsius ');
    text=text.replace(/\$(\s*\d+(?:\.\d+)?)/g,(_,num)=>` ${num.replace(/\s+/g,'')} usd `);
    text=text.replace(/\$/g,' usd ');
    text=text.replace(/(?<=[\p{L}\p{N}])['â€™](?=[\p{L}\p{N}])/gu,'');
    text=text.replace(/[-â€â€‘â€’â€“â€”âˆ’ï¹˜ï¹£ï¼]/gu,' ');
    text=text.replace(/[\p{P}\p{S}]/gu,' ');
    const raw=text.split(/\s+/).filter(Boolean);
    if(!raw.length) return [];
    const merged=mergeContractions(raw);
    return merged.map(canonicalizeToken).filter(Boolean);
  }

  const norm=s=>canonicalTokens(s).join(' ');
  const toks=s=>canonicalTokens(s);
  // é€£ç¶šé‡è¤‡ã‚’åœ§ç¸®ï¼ˆa a a â†’ aï¼‰
  function dedupeRuns(arr){
    const out=[]; for(const w of arr){ if(out.length && out[out.length-1]===w) continue; out.push(w); }
    return out;
  }

  function approxWithin1(a,b){
    if(!a || !b) return false;
    if(a===b) return true;
    const la=a.length, lb=b.length;
    if(Math.abs(la-lb)>1) return false;
    let i=0,j=0,diff=0;
    while(i<la && j<lb){
      if(a[i]===b[j]){ i++; j++; continue; }
      if(++diff>1) return false;
      if(la>lb) i++;
      else if(lb>la) j++;
      else { i++; j++; }
    }
    diff += (la-i) + (lb-j);
    return diff<=1;
  }
  // final æ–‡ã®â€œå¢—åˆ†â€ã ã‘ã‚’å®‰å®šãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
  function appendStableFinal(stable, fragment){
    const A = toks(stable);
    const B = toks(fragment);
    if(!B.length) return dedupeRuns(A).join(' ');
    if(!A.length) return dedupeRuns(B).join(' ');

    const strA = A.join(' ');
    const strB = B.join(' ');

    // å®Œå…¨åŒ…å«ãƒã‚§ãƒƒã‚¯
    if(strB.includes(strA)){
      return dedupeRuns(B).join(' ');
    }
    if(strA.includes(strB)){
      return dedupeRuns(A).join(' ');
    }

    // æœ«å°¾ã¨å…ˆé ­ã®æœ€å¤§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã‚’æ¢ç´¢ï¼ˆ1ãƒˆãƒ¼ã‚¯ãƒ³ã®èª¤å·®ã‚’è¨±å®¹ï¼‰
    let overlap = 0;
    const maxOverlap = Math.min(A.length, B.length);
    outer: for(let k=maxOverlap; k>0; k--){
      for(let i=0; i<k; i++){
        if(!approxWithin1(A[A.length-k+i], B[i])) continue outer;
      }
      overlap = k;
      break;
    }
    if(overlap>0){
      return dedupeRuns(A.concat(B.slice(overlap))).join(' ');
    }

    // ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã—ãªã„å ´åˆã¯ã‚ˆã‚Šé•·ã„æ–¹ã‚’å„ªå…ˆ
    return dedupeRuns((B.length>=A.length ? B : A)).join(' ');
  }
  function spanify(text){
    const parts=(text||'').split(/(\s+)/);
    return parts.map(part=>{
      if(!part) return '';
      if(/^[\s]+$/.test(part)){
        return part
          .replace(/\r?\n/g,'<br>')
          .replace(/[^\S\r\n]+/g,' ');
      }
      const tokens = part.match(/[\p{L}\p{N}'-]+|./gu) || [];
      return tokens.map(tok=>{
        if(/^[\p{L}\p{N}'-]+$/u.test(tok) && /[\p{L}\p{N}]/u.test(tok)){
          const clean = tok.replace(/[^\p{L}\p{N}'-]/gu,'');
          return `<span class="tok" data-w="${clean}">${tok}</span>`;
        }
        return tok;
      }).join('');
    }).join('');
  }
  function toast(msg, ms=1500){ const t=qs('#toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none', ms); }

  const DAY_MS=86400000;
  const STUDY_LOG_KEY='studyLogV1';
  const NOTIF_STATE_KEY='notifStateV1';
  function localDateKey(time=Date.now()){
    const d=new Date(time);
    d.setMinutes(d.getMinutes()-d.getTimezoneOffset());
    return d.toISOString().slice(0,10);
  }
  function loadStudyLog(){
    try{
      const raw=localStorage.getItem(STUDY_LOG_KEY);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed && typeof parsed==='object'?parsed:{};
    }catch(_){ return {}; }
  }
  function saveStudyLog(log){
    try{ localStorage.setItem(STUDY_LOG_KEY, JSON.stringify(log||{})); }catch(_){ }
  }
  function pruneStudyLog(log){
    const entries=Object.entries(log||{});
    if(entries.length<=190) return log;
    entries.sort((a,b)=>a[0]<b[0]?-1:1);
    return Object.fromEntries(entries.slice(-190));
  }
  let STUDY_LOG=pruneStudyLog(loadStudyLog());
  function recordStudyProgress({pass=false,newLevel5=false}={}){
    const key=localDateKey();
    const entry=STUDY_LOG[key]||{passes:0,level5:0};
    if(pass) entry.passes=(entry.passes||0)+1;
    if(newLevel5) entry.level5=(entry.level5||0)+1;
    STUDY_LOG[key]=entry;
    STUDY_LOG=pruneStudyLog(STUDY_LOG);
    saveStudyLog(STUDY_LOG);
    if(pass||newLevel5) scheduleNotificationCheckSoon();
  }
  function getDailyStats(key){
    const target=key||localDateKey();
    const entry=STUDY_LOG[target];
    return {passes:entry?.passes||0, level5:entry?.level5||0};
  }
  function sumRange(startKey,endKey){
    const res={passes:0, level5:0};
    if(!startKey||!endKey) return res;
    let cur=startKey;
    while(cur<=endKey){
      const st=STUDY_LOG[cur];
      if(st){
        res.passes+=st.passes||0;
        res.level5+=st.level5||0;
      }
      const parts=cur.split('-').map(n=>parseInt(n,10));
      if(parts.length>=3 && parts.every(n=>Number.isFinite(n))){
        const d=new Date(parts[0], parts[1]-1, parts[2]);
        d.setDate(d.getDate()+1);
        cur=localDateKey(d.getTime());
      }else{
        break;
      }
    }
    return res;
  }
  function loadNotifState(){
    try{
      const raw=localStorage.getItem(NOTIF_STATE_KEY);
      if(!raw) return {};
      const parsed=JSON.parse(raw);
      return parsed && typeof parsed==='object'?parsed:{};
    }catch(_){ return {}; }
  }
  function saveNotifState(state){
    try{ localStorage.setItem(NOTIF_STATE_KEY, JSON.stringify(state||{})); }catch(_){ }
  }
  function pruneNotifState(state){
    const out=Object.assign({dailyZero:{},dailyCompare:{},weeklyCompare:{}}, state||{});
    const limitDate=localDateKey(Date.now()-DAY_MS*120);
    for(const [key,value] of Object.entries(out.dailyZero||{})){
      if(key<limitDate) delete out.dailyZero[key];
      else if(value && typeof value==='object'){
        for(const slot of Object.keys(value)){
          if(!value[slot]) delete value[slot];
        }
      }
    }
    for(const key of Object.keys(out.dailyCompare||{})){
      if(key<limitDate) delete out.dailyCompare[key];
    }
    const weekLimit=localDateKey(Date.now()-DAY_MS*180);
    for(const key of Object.keys(out.weeklyCompare||{})){
      if(key<weekLimit) delete out.weeklyCompare[key];
    }
    return out;
  }
  let NOTIF_STATE=pruneNotifState(loadNotifState());
  function markDailyZeroNotified(dateKey, slot){
    if(!dateKey||!slot) return;
    if(!NOTIF_STATE.dailyZero) NOTIF_STATE.dailyZero={};
    const entry=NOTIF_STATE.dailyZero[dateKey]||{};
    entry[slot]=Date.now();
    NOTIF_STATE.dailyZero[dateKey]=entry;
    NOTIF_STATE=pruneNotifState(NOTIF_STATE);
    saveNotifState(NOTIF_STATE);
  }
  function hasDailyZeroNotified(dateKey, slot){
    return !!(NOTIF_STATE.dailyZero && NOTIF_STATE.dailyZero[dateKey] && NOTIF_STATE.dailyZero[dateKey][slot]);
  }
  function markDailyCompareNotified(dateKey){
    if(!dateKey) return;
    if(!NOTIF_STATE.dailyCompare) NOTIF_STATE.dailyCompare={};
    NOTIF_STATE.dailyCompare[dateKey]=Date.now();
    NOTIF_STATE=pruneNotifState(NOTIF_STATE);
    saveNotifState(NOTIF_STATE);
  }
  function hasDailyCompareNotified(dateKey){
    return !!(NOTIF_STATE.dailyCompare && NOTIF_STATE.dailyCompare[dateKey]);
  }
  function markWeeklyCompareNotified(weekKey){
    if(!weekKey) return;
    if(!NOTIF_STATE.weeklyCompare) NOTIF_STATE.weeklyCompare={};
    NOTIF_STATE.weeklyCompare[weekKey]=Date.now();
    NOTIF_STATE=pruneNotifState(NOTIF_STATE);
    saveNotifState(NOTIF_STATE);
  }
  function hasWeeklyCompareNotified(weekKey){
    return !!(NOTIF_STATE.weeklyCompare && NOTIF_STATE.weeklyCompare[weekKey]);
  }

  function describeStudy(stats){
    const passes=stats?.passes||0;
    const level5=stats?.level5||0;
    const parts=[`åˆæ ¼${passes}`];
    if(level5>0) parts.push(`Lv5 ${level5}`);
    return parts.join(' / ');
  }
  function startOfWeek(date){
    const d=new Date(date.getTime());
    d.setHours(0,0,0,0);
    const day=d.getDay();
    const diff=(day+6)%7; // Monday=0
    d.setDate(d.getDate()-diff);
    return d;
  }
  async function showStudyNotification(title, options){
    if(!('Notification' in window) || Notification.permission!=='granted') return false;
    const opts=Object.assign({icon:'./icons/icon-192.png', badge:'./icons/icon-192.png'}, options||{});
    try{
      if(navigator.serviceWorker && navigator.serviceWorker.ready){
        const reg=await navigator.serviceWorker.ready;
        if(reg && reg.showNotification){
          await reg.showNotification(title, opts);
          return true;
        }
      }
    }catch(err){
      console.warn('showNotification via SW failed', err);
    }
    try{
      new Notification(title, opts);
      return true;
    }catch(err){
      console.warn('Notification constructor failed', err);
      return false;
    }
  }
  const DAILY_ZERO_SLOTS=[
    {label:'12:00', hour:12, minute:0},
    {label:'18:00', hour:18, minute:0},
    {label:'21:00', hour:21, minute:0}
  ];
  async function checkDailyZeroReminders(now, stats){
    const todayKey=localDateKey(now.getTime());
    const total=(stats?.passes||0)+(stats?.level5||0);
    if(total>0) return;
    for(const slot of DAILY_ZERO_SLOTS){
      const scheduled=new Date(now.getTime());
      scheduled.setHours(slot.hour, slot.minute, 0, 0);
      if(now>=scheduled && !hasDailyZeroNotified(todayKey, slot.label)){
        const body='ä»Šæ—¥ã®åˆæ ¼ã¯ã¾ã 0ä»¶ã€‚ã‚µã‚¯ãƒƒã¨1ãƒ•ãƒ¬ãƒ¼ã‚ºã ã‘ã§ã‚‚ç™ºå£°ã—ã¦ãŠã“ã†ï¼';
        await showStudyNotification('ä»Šæ—¥ã®å­¦ç¿’ãŒã¾ã å§‹ã¾ã£ã¦ã„ã¾ã›ã‚“', {
          body,
          tag:`daily-zero-${todayKey}-${slot.label}`
        });
        markDailyZeroNotified(todayKey, slot.label);
        break;
      }
    }
  }
  async function checkDailyComparison(now, todayStats){
    if(now.getHours()<18) return;
    const todayKey=localDateKey(now.getTime());
    if(hasDailyCompareNotified(todayKey)) return;
    const yesterdayKey=localDateKey(now.getTime()-DAY_MS);
    const yesterdayStats=getDailyStats(yesterdayKey);
    const todayTotal=(todayStats.passes||0)+(todayStats.level5||0);
    const yTotal=(yesterdayStats.passes||0)+(yesterdayStats.level5||0);
    if(todayTotal===0 && yTotal===0) return;
    let title='ä»Šæ—¥ã®é€²æ—';
    let body='';
    if(todayTotal<yTotal){
      const diff=yTotal-todayTotal;
      title='æ˜¨æ—¥ã«è¿½ã„ã¤ããƒãƒ£ãƒ³ã‚¹ï¼';
      body=`æ˜¨æ—¥ã¯${describeStudy(yesterdayStats)}ã§ã—ãŸãŒã€ä»Šæ—¥ã¯ã¾ã ${describeStudy(todayStats)}ã€‚ã‚ã¨${diff}ä»¶å·»ãè¿”ãã†ï¼`;
    }else if(todayTotal>yTotal){
      const diff=todayTotal-yTotal;
      title='æ˜¨æ—¥ã‚’è¶…ãˆã‚‹ãƒã‚¤ãƒšãƒ¼ã‚¹ï¼';
      body=`æ˜¨æ—¥ã¯${describeStudy(yesterdayStats)}ã€‚ä»Šæ—¥ã¯${describeStudy(todayStats)}ã§${diff}ä»¶ãƒªãƒ¼ãƒ‰ä¸­ã€‚ã“ã®ã¾ã¾ç· ã‚åˆ‡ã‚ã†ï¼`;
    }else{
      title='æ˜¨æ—¥ã¨äº’è§’ã®ãƒšãƒ¼ã‚¹';
      body=`æ˜¨æ—¥ã¯${describeStudy(yesterdayStats)}ã€‚ä»Šæ—¥ã¯ä»Šã®ã¨ã“ã‚åŒã˜ã ã‘é€²ã‚“ã§ã„ã¾ã™ã€‚ãƒ©ã‚¹ãƒˆ1ä»¶ã§å·®ã‚’ã¤ã‘ã‚ˆã†ï¼`;
    }
    await showStudyNotification(title, {
      body,
      tag:`daily-compare-${todayKey}`
    });
    markDailyCompareNotified(todayKey);
  }
  async function checkWeeklyComparison(now){
    if(now.getDay()!==1 || now.getHours()<9) return;
    const thisWeek=startOfWeek(now);
    const weekKey=localDateKey(thisWeek.getTime());
    if(hasWeeklyCompareNotified(weekKey)) return;
    const lastWeekStart=new Date(thisWeek.getTime()-DAY_MS*7);
    const lastWeekEnd=new Date(lastWeekStart.getTime()+DAY_MS*6);
    const prevWeekStart=new Date(lastWeekStart.getTime()-DAY_MS*7);
    const prevWeekEnd=new Date(prevWeekStart.getTime()+DAY_MS*6);
    const lastStats=sumRange(localDateKey(lastWeekStart.getTime()), localDateKey(lastWeekEnd.getTime()));
    const prevStats=sumRange(localDateKey(prevWeekStart.getTime()), localDateKey(prevWeekEnd.getTime()));
    const lastTotal=(lastStats.passes||0)+(lastStats.level5||0);
    const prevTotal=(prevStats.passes||0)+(prevStats.level5||0);
    if(lastTotal===0 && prevTotal===0) return;
    let title='å…ˆé€±ã®æŒ¯ã‚Šè¿”ã‚Š';
    let body='';
    if(lastTotal<prevTotal){
      const diff=prevTotal-lastTotal;
      title='å…ˆé€±ã¯å¤±é€Ÿæ°—å‘³â€¦';
      body=`å…ˆé€±ã¯${describeStudy(lastStats)}ã§ã€å‰ã®é€±ã¯${describeStudy(prevStats)}ã€‚ä»Šé€±ã¯${diff}ä»¶å–ã‚Šè¿”ã—ã¦æµã‚Œã‚’æˆ»ãã†ï¼`;
    }else if(lastTotal>prevTotal){
      const diff=lastTotal-prevTotal;
      title='å…ˆé€±ã¯ã—ã£ã‹ã‚Šç©ã¿ä¸Šã’ï¼';
      body=`å…ˆé€±ã¯${describeStudy(lastStats)}ã§å‰ã®é€±ã‚’${diff}ä»¶ä¸Šå›ã‚Šã¾ã—ãŸã€‚ã“ã®å‹¢ã„ã§ä»Šé€±ã‚‚æ›´æ–°ã—ã‚ˆã†ï¼`;
    }else{
      title='å…ˆé€±ã¯æ¨ªã°ã„ãƒšãƒ¼ã‚¹';
      body=`å…ˆé€±ã¯${describeStudy(lastStats)}ã§ã€å‰ã®é€±ã¨åŒã˜çµæœã§ã—ãŸã€‚ä»Šé€±ã¯ã‚‚ã†ä¸€æ­©æ”»ã‚ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ`;
    }
    await showStudyNotification(title, {
      body,
      tag:`weekly-compare-${weekKey}`
    });
    markWeeklyCompareNotified(weekKey);
  }
  let notifInterval=null;
  function stopNotificationLoop(){
    if(notifInterval){
      clearInterval(notifInterval);
      notifInterval=null;
    }
  }
  async function runNotificationChecks({force=false}={}){
    if(!('Notification' in window) || Notification.permission!=='granted'){
      stopNotificationLoop();
      return;
    }
    const now=new Date();
    const todayKey=localDateKey(now.getTime());
    const todayStats=getDailyStats(todayKey);
    await checkDailyZeroReminders(now, todayStats);
    await checkDailyComparison(now, todayStats);
    await checkWeeklyComparison(now);
  }
  function ensureNotificationLoop(){
    if(!('Notification' in window) || Notification.permission!=='granted') return;
    if(notifInterval) return;
    notifInterval=setInterval(()=>{ runNotificationChecks().catch(()=>{}); }, 10*60*1000);
    runNotificationChecks({force:true}).catch(()=>{});
  }
  function updateNotificationUi(){
    if(!el.notifStatus || !el.notifBtn) return;
    if(!('Notification' in window)){
      el.notifStatus.textContent='é€šçŸ¥éå¯¾å¿œã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™';
      el.notifBtn.disabled=true;
      return;
    }
    const perm=Notification.permission;
    if(perm==='granted'){
      el.notifStatus.textContent='é€šçŸ¥ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™';
      el.notifBtn.textContent='é€šçŸ¥ã¯è¨±å¯æ¸ˆã¿';
      el.notifBtn.disabled=true;
    }else if(perm==='denied'){
      el.notifStatus.textContent='ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã§é€šçŸ¥ã‚’è¨±å¯ã—ã¦ãã ã•ã„';
      el.notifBtn.textContent='é€šçŸ¥ã‚’è¨±å¯ã§ãã¾ã›ã‚“';
      el.notifBtn.disabled=true;
    }else{
      el.notifStatus.textContent='æœªè¨±å¯ï¼šã‚¿ãƒƒãƒ—ã§æœ‰åŠ¹åŒ–';
      el.notifBtn.textContent='å­¦ç¿’ãƒªãƒã‚¤ãƒ³ãƒ‰é€šçŸ¥ã‚’æœ‰åŠ¹åŒ–';
      el.notifBtn.disabled=false;
    }
  }
  function initNotificationSystem(){
    if(!el.notifBtn || !el.notifStatus) return;
    updateNotificationUi();
    if('Notification' in window && Notification.permission==='granted'){
      ensureNotificationLoop();
    }
    el.notifBtn.addEventListener('click', async()=>{
      if(!('Notification' in window)){
        toast('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯é€šçŸ¥ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
        return;
      }
      if(Notification.permission==='granted'){
        toast('é€šçŸ¥ã¯ã™ã§ã«æœ‰åŠ¹ã§ã™');
        return;
      }
      try{
        const result=await Notification.requestPermission();
        updateNotificationUi();
        if(result==='granted'){
          toast('é€šçŸ¥ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ');
          ensureNotificationLoop();
          runNotificationChecks({force:true}).catch(()=>{});
        }else{
          toast('é€šçŸ¥ã¯è¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
        }
      }catch(err){
        console.warn('Notification permission request failed', err);
        toast('é€šçŸ¥ã®è¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    });
    document.addEventListener('visibilitychange',()=>{
      if(document.visibilityState==='visible'){
        updateNotificationUi();
        runNotificationChecks({force:true}).catch(()=>{});
      }
    });
  }
  function scheduleNotificationCheckSoon(){
    if(!('Notification' in window) || Notification.permission!=='granted') return;
    ensureNotificationLoop();
    clearTimeout(scheduleNotificationCheckSoon._t);
    scheduleNotificationCheckSoon._t=setTimeout(()=>{
      runNotificationChecks({force:true}).catch(()=>{});
    }, 1000);
  }

  const LEVEL_KEY='itemLevelV1';
  function loadLevelState(){ try{ return JSON.parse(localStorage.getItem(LEVEL_KEY)||'{}'); }catch(_){ return {}; } }
  function saveLevelState(state){ try{ localStorage.setItem(LEVEL_KEY, JSON.stringify(state)); }catch(_){ } }
  let LEVEL_STATE=loadLevelState();
  const LEVEL_FILTER_KEY='levelFilterV1';
  const SEARCH_KEY='itemSearchV1';
  function loadSearchQuery(){
    try{
      return localStorage.getItem(SEARCH_KEY)||'';
    }catch(_){
      return '';
    }
  }
  function saveSearchQuery(value){
    try{ localStorage.setItem(SEARCH_KEY, value); }catch(_){ }
  }
  function currentSearchQuery(){
    const input=document.getElementById('rangeSearch');
    const raw=(input && typeof input.value==='string') ? input.value : '';
    return raw.trim();
  }
  const LEVEL_CHOICES=[1,2,3,4,5];
  function loadLevelFilter(){
    try{
      const raw=localStorage.getItem(LEVEL_FILTER_KEY);
      if(!raw) return new Set(LEVEL_CHOICES);
      const parsed=JSON.parse(raw);
      if(Array.isArray(parsed)){
        const valid=parsed.map(n=>Number(n)).filter(n=>LEVEL_CHOICES.includes(n));
        if(valid.length) return new Set(valid);
      }
    }catch(_){ }
    return new Set(LEVEL_CHOICES);
  }
  function saveLevelFilter(set){
    if(!(set instanceof Set)) return;
    const arr=LEVEL_CHOICES.filter(l=>set.has(l));
    try{ localStorage.setItem(LEVEL_FILTER_KEY, JSON.stringify(arr)); }catch(_){ }
  }
  let LEVEL_FILTER=loadLevelFilter();
  function activeLevelArray(){
    if(!(LEVEL_FILTER instanceof Set) || LEVEL_FILTER.size===0){
      LEVEL_FILTER=new Set(LEVEL_CHOICES);
    }
    const arr=LEVEL_CHOICES.filter(l=>LEVEL_FILTER.has(l));
    return arr.length?arr:LEVEL_CHOICES.slice();
  }
  function evaluateLevel(matchRate, hintStageUsed){
    const rate=Math.max(0, Math.min(1, matchRate||0));
    const stage = Number.isFinite(hintStageUsed) ? Math.max(0, Math.floor(hintStageUsed)) : BASE_HINT_STAGE;
    if(rate < 0.70) return 2;
    if(rate < 0.90) return 3;
    if(stage <= BASE_HINT_STAGE){
      return 5;
    }
    if(stage===BASE_HINT_STAGE+1){
      return 4;
    }
    return 3;
  }
  function getLevelInfo(id){
    if(!id) return {best:1,last:1};
    return LEVEL_STATE[id] || {best:1,last:1};
  }
  function updateLevelInfo(id, levelCandidate, matchRate, hintStageUsed){
    if(!id) return {best:levelCandidate,last:levelCandidate};
    const info=LEVEL_STATE[id] || {best:1,last:1};
    info.last = levelCandidate;
    if(levelCandidate > (info.best||1)) info.best = levelCandidate;
    info.lastMatch = +(matchRate||0);
    info.hintStage = hintStageUsed;
    info.updatedAt = Date.now();
    LEVEL_STATE[id]=info;
    saveLevelState(LEVEL_STATE);
    return info;
  }
  function refreshLevelDisplay(info){
    if(!el.level) return;
    if(!info){ el.level.textContent='â€”'; return; }
    const last = info.last || info.best || 1;
    const best = info.best || last;
    el.level.textContent = best>last ? `${last} / ${best}` : `${last}`;
  }

  function lastRecordedLevel(id){
    const info=getLevelInfo(id);
    return info.last || info.best || 1;
  }

  function updateLevelFilterButtons(){
    if(!el.levelFilter) return;
    const active=new Set(activeLevelArray());
    qsa('button[data-level]', el.levelFilter).forEach(btn=>{
      const level=Number(btn.dataset.level||'0');
      const on=active.has(level);
      btn.classList.toggle('active', on);
      btn.setAttribute('aria-pressed', on?'true':'false');
    });
  }

  function initLevelFilterUI(){
    if(!el.levelFilter) return;
    el.levelFilter.innerHTML='';
    const label=document.createElement('span');
    label.className='level-filter-label';
    label.textContent='Lv';
    el.levelFilter.appendChild(label);
    const btnWrap=document.createElement('div');
    btnWrap.className='level-filter-buttons';
    el.levelFilter.appendChild(btnWrap);
    const activeLevels=new Set(activeLevelArray());
    for(const level of LEVEL_CHOICES){
      const btn=document.createElement('button');
      btn.type='button';
      btn.className='level-chip';
      btn.dataset.level=String(level);
      btn.textContent=String(level);
      if(activeLevels.has(level)){
        btn.classList.add('active');
        btn.setAttribute('aria-pressed','true');
      }else{
        btn.setAttribute('aria-pressed','false');
      }
      btn.addEventListener('click',()=>{
        if(!(LEVEL_FILTER instanceof Set)){
          LEVEL_FILTER=new Set(LEVEL_CHOICES);
        }
        if(LEVEL_FILTER.has(level)){
          if(LEVEL_FILTER.size===1){
            LEVEL_FILTER=new Set(LEVEL_CHOICES);
          }else{
            LEVEL_FILTER.delete(level);
          }
        }else{
          LEVEL_FILTER.add(level);
        }
        if(!LEVEL_FILTER.size){
          LEVEL_FILTER=new Set(LEVEL_CHOICES);
        }
        saveLevelFilter(LEVEL_FILTER);
        updateLevelFilterButtons();
        rebuildAndRender(true);
      });
      btnWrap.appendChild(btn);
    }
    updateLevelFilterButtons();
  }


  let toneCtx=null;
  function playTone(type){
    try{
      const AC=window.AudioContext||window.webkitAudioContext;
      if(!AC) return;
      if(!toneCtx){ toneCtx=new AC(); }
      if(toneCtx.state==='suspended'){ toneCtx.resume().catch(()=>{}); }
      const osc=toneCtx.createOscillator();
      const gain=toneCtx.createGain();
      const now=toneCtx.currentTime;
      let freq=440, duration=0.2, peak=0.15;
      if(type==='success'){ freq=880; duration=0.25; peak=0.2; }
      else if(type==='fail'){ freq=300; duration=0.3; peak=0.18; }
      else if(type==='start'){ freq=523.25; duration=0.12; peak=0.12; }
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(peak, now+0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now+duration);
      osc.connect(gain);
      gain.connect(toneCtx.destination);
      osc.start(now);
      osc.stop(now+duration+0.05);
    }catch(_){ }
  }

  // ===== Elements =====
  const el={ headerSection:qs('#statSection'), headerLevelAvg:qs('#statLevelAvg'), headerProgressCurrent:qs('#statProgressCurrent'), headerProgressTotal:qs('#statProgressTotal'), pbar:qs('#pbar'), footer:qs('#footerInfo'), en:qs('#enText'), ja:qs('#jaText'), chips:qs('#chips'), match:qs('#valMatch'), level:qs('#valLevel'), attempt:qs('#attemptInfo'), next:qs('#btnNext'), play:qs('#btnPlay'), mic:qs('#btnMic'), card:qs('#card'), secSel:qs('#secSel'), orderSel:qs('#orderSel'), search:qs('#rangeSearch'), levelFilter:qs('#levelFilter'), cfgBtn:qs('#btnCfg'), cfgModal:qs('#cfgModal'), cfgUrl:qs('#cfgUrl'), cfgKey:qs('#cfgKey'), cfgAudioBase:qs('#cfgAudioBase'), cfgSave:qs('#cfgSave'), cfgClose:qs('#cfgClose'), btnImport:qs('#btnImport'), filePick:qs('#filePick'), btnTestAudio:qs('#btnTestAudio'), btnPickDir:qs('#btnPickDir'), btnClearDir:qs('#btnClearDir'), dirStatus:qs('#dirStatus'), overlay:qs('#loadingOverlay'), dirPermOverlay:qs('#dirPermOverlay'), dirPermAllow:qs('#dirPermAllow'), dirPermLater:qs('#dirPermLater'), dirPermStatus:qs('#dirPermStatus'), speed:qs('#speedSlider'), speedDown:qs('#speedDown'), speedUp:qs('#speedUp'), speedValue:qs('#speedValue'), notifBtn:qs('#btnNotifPerm'), notifStatus:qs('#notifStatus') };
  const audio=qs('#player');
  let recog=null, recogOn=false;
  let resumeAfterMicStart=false;
  let resumeAfterMicTimer=null;
  function clearResumeTimer(){ if(resumeAfterMicTimer){ clearTimeout(resumeAfterMicTimer); resumeAfterMicTimer=null; } }
  const overlayLocks=new Set();
  function updateOverlayState(){ if(!el.overlay) return; const active=overlayLocks.size>0; el.overlay.classList.toggle('hidden', !active); el.overlay.classList.toggle('active', active); }
  function acquireOverlay(tag='load'){ if(!el.overlay){ return ()=>{}; } const token=`${tag}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`; overlayLocks.add(token); updateOverlayState(); return ()=>releaseOverlay(token); }
  function releaseOverlay(token){ if(!el.overlay || token==null) return; if(overlayLocks.delete(token)){ updateOverlayState(); } }
  function updatePlayButtonAvailability(){ if(!el.play) return; const hasSrc=!!audio.dataset.srcKey; el.play.disabled=!hasSrc; }
  function updatePlayVisualState(){ if(!el.play) return; const playing=!audio.paused && !audio.ended; el.play.classList.toggle('playing', playing); el.play.setAttribute('aria-pressed', playing?'true':'false'); const icon=el.play.querySelector('.playIcon'); if(icon){ icon.textContent = playing ? 'â¸' : 'â–¶ï¸'; } }
  audio.addEventListener('play', ()=>{ resumeAfterMicStart=false; clearResumeTimer(); updatePlayVisualState(); });
  audio.addEventListener('playing', ()=>{ resumeAfterMicStart=false; clearResumeTimer(); updatePlayVisualState(); });
  audio.addEventListener('pause', ()=>{
    updatePlayVisualState();
    if(!resumeAfterMicStart || !recogOn){ return; }
    if(audio.ended){ resumeAfterMicStart=false; clearResumeTimer(); return; }
    clearResumeTimer();
    resumeAfterMicTimer=setTimeout(()=>{
      resumeAfterMicTimer=null;
      if(!resumeAfterMicStart || !recogOn || audio.ended){ resumeAfterMicStart=false; return; }
      audio.play().catch(err=>{ console.warn('resume after mic start failed', err); resumeAfterMicStart=false; });
    }, 150);
  });
  audio.addEventListener('ended', ()=>{ resumeAfterMicStart=false; clearResumeTimer(); updatePlayVisualState(); });
  audio.addEventListener('emptied', ()=>{ resumeAfterMicStart=false; clearResumeTimer(); updatePlayButtonAvailability(); updatePlayVisualState(); });
  audio.addEventListener('loadeddata', updatePlayButtonAvailability);
  updatePlayVisualState();
  updatePlayButtonAvailability();
  const SPEED_KEY='audioSpeedV1';
  function clampSpeed(value){
    const num=(typeof value==='number')?value:parseFloat(value);
    if(!Number.isFinite(num)) return 1;
    return Math.min(1.5, Math.max(0.5, num));
  }
  function loadSpeed(){
    try{
      const raw=localStorage.getItem(SPEED_KEY);
      if(raw==null) return 1;
      return clampSpeed(parseFloat(raw));
    }catch(_){
      return 1;
    }
  }
  function saveSpeed(rate){
    try{ localStorage.setItem(SPEED_KEY, String(rate)); }catch(_){ }
  }
  let playbackRate=loadSpeed();
  function formatSpeed(rate){
    const rounded=Math.round(rate*100)/100;
    return `${rounded.toFixed(2).replace(/\.?0+$/,'')}Ã—`;
  }
  function syncSpeedUI(){
    if(el.speed){
      const val=Math.round(playbackRate*100)/100;
      el.speed.value=String(val);
    }
    if(el.speedValue){
      el.speedValue.textContent=formatSpeed(playbackRate);
    }
  }
  function applyPlaybackRate(rate,{persist=false}={}){
    const clamped=clampSpeed(rate);
    playbackRate=clamped;
    if(audio){
      try{ audio.playbackRate=clamped; }catch(_){ }
    }
    syncSpeedUI();
    if(persist){ saveSpeed(clamped); }
  }
  function stepPlaybackRate(delta){
    const stepped=Math.round((playbackRate+delta)*20)/20;
    applyPlaybackRate(stepped,{persist:true});
  }
  applyPlaybackRate(playbackRate);
  if(el.speed){
    el.speed.addEventListener('input', ()=>{
      applyPlaybackRate(parseFloat(el.speed.value), {persist:true});
    });
    el.speed.addEventListener('change', ()=>{
      applyPlaybackRate(parseFloat(el.speed.value), {persist:true});
    });
  }
  if(el.speedDown){
    el.speedDown.addEventListener('click', ()=>stepPlaybackRate(-0.1));
  }
  if(el.speedUp){
    el.speedUp.addEventListener('click', ()=>stepPlaybackRate(0.1));
  }
  const PREFETCH_POOL=new Map();
  const PREFETCH_LIMIT=6;
  let sessionActive=false;
  let sessionStarting=false;
  let remoteStatus=null;
  let QUEUE=[];
  let idx=-1;
  let sessionStart=0;
  let cardStart=0;
  let autoPlayUnlocked=false;
  let lastEmptySearchToast='';

  function updateHeaderStats(){
    if(el.headerSection){
      let sectionLabel='â€”';
      const sel=el.secSel;
      if(sel){
        const selected = sel.selectedOptions && sel.selectedOptions.length ? sel.selectedOptions[0] : null;
        if(selected){
          sectionLabel=(selected.textContent||selected.label||selected.value||'').trim();
        }
        if(!sectionLabel){
          if(sel.value){
            sectionLabel=String(sel.value).trim();
          }else if(sel.options.length){
            const first=sel.options[0];
            sectionLabel=(first.textContent||first.label||first.value||'').trim();
          }
        }
        if(!sectionLabel && sel.value==='') sectionLabel='å…¨ä½“';
      }
      if(!sectionLabel) sectionLabel='â€”';
      const query=currentSearchQuery();
      if(query){
        const suffix=(sectionLabel && sectionLabel!=='â€”') ? ` (${sectionLabel})` : '';
        el.headerSection.textContent=`æ¤œç´¢: ${query}${suffix}`;
      }else{
        el.headerSection.textContent=sectionLabel;
      }
    }

    if(el.headerLevelAvg){
      const secKey = el.secSel ? el.secSel.value : '';
      const pool = secKey ? (ITEMS_BY_SECTION.get(secKey)||[]) : (window.ALL_ITEMS||[]);
      let sum=0;
      let count=0;
      for(const item of pool){
        if(!item) continue;
        const info=getLevelInfo(item.id);
        let val = info ? Number(info.last) : NaN;
        if(!Number.isFinite(val)) val = info ? Number(info.best) : NaN;
        if(!Number.isFinite(val) || val<=0) val=1;
        sum+=val;
        count++;
      }
      if(count>0){
        const avg=sum/count;
        let text=avg.toFixed(1);
        if(text.endsWith('.0')) text=text.slice(0,-2);
        el.headerLevelAvg.textContent=text;
      }else{
        el.headerLevelAvg.textContent='â€”';
      }
    }

    if(el.headerProgressCurrent){
      const total=Array.isArray(QUEUE)?QUEUE.length:0;
      const shown=(sessionActive && idx>=0) ? Math.min(idx+1, total) : 0;
      el.headerProgressCurrent.textContent = shown;
      if(el.headerProgressTotal){
        el.headerProgressTotal.textContent = total;
      }
    }
  }

  function applyRemoteStatus(status){
    remoteStatus = status ? Object.assign({}, status) : null;
    updateHeaderStats();
  }

  function waitForAudioReady(el, timeout=2000){
    if(!el) return Promise.resolve();
    if(el.readyState>=2) return Promise.resolve();
    return new Promise(resolve=>{
      let settled=false;
      const finalize=()=>{
        if(settled) return;
        settled=true;
        el.removeEventListener('canplay', onReady);
        el.removeEventListener('canplaythrough', onReady);
        el.removeEventListener('loadeddata', onReady);
        el.removeEventListener('error', onReady);
        clearTimeout(timer);
        resolve();
      };
      const onReady=()=>finalize();
      const timer=setTimeout(()=>finalize(), timeout);
      el.addEventListener('canplay', onReady, {once:true});
      el.addEventListener('canplaythrough', onReady, {once:true});
      el.addEventListener('loadeddata', onReady, {once:true});
      el.addEventListener('error', onReady, {once:true});
    });
  }

  function setAudioSource(url,{timeout=2000, forceReload=false}={}){
    if(!url){
      clearAudioSource();
      return Promise.resolve();
    }
    if(forceReload || audio.dataset.srcKey !== url){
      audio.dataset.srcKey = url;
      audio.src = url;
      try{ audio.playbackRate = playbackRate; }catch(_){ }
    }
    updatePlayButtonAvailability();
    try{ audio.playbackRate = playbackRate; }catch(_){ }
    try{ audio.load?.(); }catch(_){ }
    return waitForAudioReady(audio, timeout);
  }

  function clearAudioSource(){
    resumeAfterMicStart=false;
    clearResumeTimer();
    delete audio.dataset.srcKey;
    audio.removeAttribute('src');
    try{ audio.load?.(); }catch(_){ }
    updatePlayButtonAvailability();
    updatePlayVisualState();
  }

  function rememberPrefetch(url, entry){
    PREFETCH_POOL.set(url, entry);
    if(PREFETCH_POOL.size>PREFETCH_LIMIT){
      const firstKey=PREFETCH_POOL.keys().next().value;
      const old=PREFETCH_POOL.get(firstKey);
      if(old && old.audio){
        try{ old.audio.pause?.(); }catch(_){ }
        old.audio.removeAttribute?.('src');
      }
      PREFETCH_POOL.delete(firstKey);
    }
  }

  const FAIL_LIMIT=3;
  let failCount=0;

  const BASE_HINT_STAGE=0;
  let hintStage=BASE_HINT_STAGE;
  let maxHintStageUsed=BASE_HINT_STAGE;
  let currentEnHtml='';
  let currentItem=null;

  function setHintStage(stage,{reset=false}={}){
    const next=Math.max(0, Math.min(2, Number.isFinite(stage)?Math.floor(stage):0));
    const prev=hintStage;
    hintStage=next;
    if(reset){ maxHintStageUsed=next; }
    else if(next>maxHintStageUsed){ maxHintStageUsed=next; }
    if(next<=0){
      el.en.classList.add('concealed');
      el.en.innerHTML='<span class="hint-placeholder">ä¸Šã«ã‚¹ãƒ¯ã‚¤ãƒ—ã—ã¦è‹±æ–‡ã‚’è¡¨ç¤ºï¼ˆå†ã‚¹ãƒ¯ã‚¤ãƒ—ã§å’Œè¨³ï¼‰</span>';
      el.ja.style.display='none';
      clearHighlight();
    }else{
      el.en.classList.remove('concealed');
      el.en.innerHTML=currentEnHtml||'';
      el.ja.style.display = next>=2 ? 'block' : 'none';
      if(currentItem && lastMatchEval && lastMatchEval.source){
        lastMatchEval = matchAndHighlight(currentItem.en, lastMatchEval.source);
        const score=calcMatchScore(lastMatchEval.refCount, lastMatchEval.recall, lastMatchEval.precision);
        updateMatch(score);
      }
    }
    return prev!==next;
  }

  function advanceHintStage(){
    if(!sessionActive) return;
    if(hintStage>=2){ toast('ãƒ’ãƒ³ãƒˆã¯ã™ã¹ã¦è¡¨ç¤ºæ¸ˆã¿ã§ã™'); return; }
    const changed=setHintStage(hintStage+1);
    if(changed){
      if(hintStage===1){ el.footer.textContent='è‹±æ–‡ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ã§å’Œè¨³ãƒ’ãƒ³ãƒˆã€‚'; }
      else if(hintStage===2){ el.footer.textContent='å’Œè¨³ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤ºã—ã¾ã—ãŸ'; }
    }
  }

  function updateMatch(rate){
    el.match.classList.remove('match-good','match-mid','match-bad');
    if(rate==null || !isFinite(rate)){
      el.match.textContent='â€”';
      return;
    }
    const pct=Math.max(0, Math.min(100, Math.round(rate*100)));
    el.match.textContent=`${pct}%`;
    if(pct>=85){ el.match.classList.add('match-good'); }
    else if(pct>=70){ el.match.classList.add('match-mid'); }
    else { el.match.classList.add('match-bad'); }
  }

  function updateAttemptInfo(){
    if(failCount<=0){ el.attempt.textContent=''; el.attempt.classList.remove('alert'); return; }
    const remain=Math.max(0, FAIL_LIMIT-failCount);
    el.attempt.textContent = remain>0 ? `ãƒªãƒˆãƒ©ã‚¤æ®‹ã‚Š ${remain}å›` : 'è¦å®šå›æ•°ã«é”ã—ã¾ã—ãŸ';
    if(remain<=1){ el.attempt.classList.add('alert'); }
    else{ el.attempt.classList.remove('alert'); }
  }

  function hideNextCta(){
    el.next.hidden=true;
    el.next.disabled=true;
    el.mic.disabled=false;
  }

  function showNextCta(){
    el.next.hidden=false;
    el.next.disabled=false;
    el.mic.disabled=true;
  }

  function setMicState(on){
    el.mic.classList.toggle('recording', !!on);
  }

  function calcMatchScore(refCount, recall, precision){
    if(!refCount) return 1;
    if((recall+precision)<=0) return 0;
    return (2*recall*precision)/(recall+precision);
  }

  // ===== Config =====
  const CFG_KEY='appConfigV3';
  function loadCfg(){ try{return JSON.parse(localStorage.getItem(CFG_KEY)||'{}')}catch(_){return{}} }
  function saveCfg(o){ localStorage.setItem(CFG_KEY, JSON.stringify(o)); }
  let CFG=Object.assign({ apiUrl:'', apiKey:'', audioBase:'./audio' }, loadCfg());

  const PENDING_KEY='pendingLogsV1';
  function loadPendingLogs(){
    try{
      const raw=JSON.parse(localStorage.getItem(PENDING_KEY)||'[]');
      if(Array.isArray(raw)) return raw.filter(entry=>entry&&entry.type&&entry.url);
    }catch(_){ }
    return [];
  }
  let PENDING_LOGS=loadPendingLogs();
  for(const entry of PENDING_LOGS){
    if(!entry.uid) entry.uid=generateUid();
    if(entry.data && !entry.data.client_uid) entry.data.client_uid=entry.uid;
  }
  rememberPending();
  function rememberPending(){ try{ localStorage.setItem(PENDING_KEY, JSON.stringify(PENDING_LOGS)); }catch(_){ } }
  function generateUid(){ if(window.crypto?.randomUUID){ try{ return crypto.randomUUID(); }catch(_){ } } return 'uid-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2); }
  let flushPromise=null;
  async function flushPendingLogs(){
    if(!PENDING_LOGS.length) return;
    if(flushPromise) return flushPromise;
    flushPromise=(async()=>{
      const accepted=new Set();
      const groups=new Map();
      for(const entry of PENDING_LOGS){
        if(!entry || !entry.url || !entry.type) continue;
        const key=`${entry.url}::${entry.apiKey||''}`;
        if(!groups.has(key)) groups.set(key,{url:entry.url, apiKey:entry.apiKey, items:[]});
        const data=Object.assign({}, entry.data||{});
        if(!data.client_uid) data.client_uid=entry.uid;
        groups.get(key).items.push({uid:entry.uid, type:entry.type, data});
      }
      for(const group of groups.values()){
        if(!group.items.length) continue;
        const payload={type:'bulk', apiKey:group.apiKey, entries:group.items};
        try{
          const res=await fetch(group.url,{method:'POST',headers:{'Content-Type':'text/plain;charset=UTF-8'},body:JSON.stringify(payload)});
          if(!res.ok) continue;
          let json=null;
          try{ json=await res.json(); }catch(_){ }
          if(json && json.ok){
            const ack=Array.isArray(json.accepted)?json.accepted:group.items.map(it=>it.uid);
            ack.forEach(uid=>accepted.add(uid));
          }
        }catch(err){ console.warn('flushPendingLogs', err); }
      }
      let changed=false;
      if(accepted.size){
        PENDING_LOGS=PENDING_LOGS.filter(entry=>!accepted.has(entry.uid));
        changed=true;
      }
      const cleaned=PENDING_LOGS.filter(entry=>entry && entry.url);
      if(cleaned.length!==PENDING_LOGS.length){
        PENDING_LOGS=cleaned;
        changed=true;
      }
      if(changed) rememberPending();
    })();
    try{
      await flushPromise;
    }finally{
      flushPromise=null;
    }
  }

  async function sendLog(type,data){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return;
    const uid=generateUid();
    const payload=Object.assign({}, data||{});
    if(!payload.client_uid) payload.client_uid=uid;
    const entry={ uid, type, data:payload, url, apiKey:(CFG.apiKey||'')||undefined, createdAt:Date.now() };
    PENDING_LOGS.push(entry);
    rememberPending();
    try{ await flushPendingLogs(); }catch(err){ console.warn('sendLog', err); }
  }

  // ===== IndexedDB for DirectoryHandle =====
  const DB='fs-handles', STORE='dir';
  function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
  async function saveDirHandle(h){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(h,'audio'); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
  async function loadDirHandle(){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const rq=tx.objectStore(STORE).get('audio'); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
  async function clearDirHandle(){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete('audio'); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }

  let DIR=null; // FileSystemDirectoryHandle
  let dirNeedsGesture=false;
  let dirPromptArmed=false;
  async function ensureDir({prompt=true, forceCheck=false, allowSchedule=true}={}){
    if(!DIR || forceCheck){
      if(!DIR){
        try{
          DIR = await loadDirHandle();
        }catch(err){
          console.warn('loadDirHandle failed', err);
          DIR=null;
          dirNeedsGesture=false;
          refreshDirStatus();
          return null;
        }
      }
    }
    if(!DIR){ dirNeedsGesture=false; refreshDirStatus(); return null; }
    let state='granted';
    try{
      state = await DIR.queryPermission?.({mode:'read'}) || 'granted';
    }catch(_){ state='prompt'; }
    if(state==='granted'){
      dirNeedsGesture=false;
      dirPromptArmed=false;
      refreshDirStatus();
      return DIR;
    }
    if(!prompt){
      dirNeedsGesture = state!=='granted';
      if(dirNeedsGesture && allowSchedule) scheduleDirPrompt();
      refreshDirStatus();
      return null;
    }
    try{
      state = await DIR.requestPermission?.({mode:'read'});
    }catch(err){
      if(err && (err.name==='InvalidStateError' || /user activation/i.test(err.message||''))){
        dirNeedsGesture=true;
        if(allowSchedule) scheduleDirPrompt();
        refreshDirStatus();
        return null;
      }
      console.warn('requestPermission error', err);
      DIR=null;
      dirNeedsGesture=false;
      refreshDirStatus();
      return null;
    }
      if(state==='granted'){
        dirNeedsGesture=false;
        dirPromptArmed=false;
        refreshDirStatus();
        return DIR;
      }
      if(state==='prompt'){
        dirNeedsGesture=true;
        if(allowSchedule) scheduleDirPrompt();
        refreshDirStatus();
        return null;
      }
      // denied or unknown
      dirNeedsGesture=false;
      dirPromptArmed=false;
      DIR=null;
      try{ await clearDirHandle(); }catch(_){ }
      refreshDirStatus();
      return null;
  }
  function scheduleDirPrompt(){
    if(!DIR || !dirNeedsGesture || dirPromptArmed) return;
    dirPromptArmed=true;
    const handler=async()=>{
      window.removeEventListener('pointerdown', handler, true);
      window.removeEventListener('keydown', handler, true);
      dirPromptArmed=false;
      const release=acquireOverlay('dir');
      try{
        await ensureDir({prompt:true});
      }finally{
        release();
      }
    };
    window.addEventListener('pointerdown', handler, true);
    window.addEventListener('keydown', handler, true);
  }

  async function gateDirPermissionBeforeBoot(){
    await ensureDir({prompt:false, forceCheck:true, allowSchedule:false});
    if(!DIR || !dirNeedsGesture){
      return;
    }
    refreshDirStatus();
    if(el.dirPermOverlay && el.dirPermAllow){
      const overlay=el.dirPermOverlay;
      const statusEl=el.dirPermStatus;
      const allowBtn=el.dirPermAllow;
      const laterBtn=el.dirPermLater;
      function hideOverlay(){
        overlay.classList.remove('show');
        overlay.setAttribute('hidden','');
        overlay.setAttribute('aria-hidden','true');
      }
      function showOverlay(){
        overlay.removeAttribute('hidden');
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden','false');
        setTimeout(()=>{ try{ allowBtn?.focus?.(); }catch(_){ } }, 0);
      }
      await new Promise(resolve=>{
        if(laterBtn){ laterBtn.hidden=true; }
        const attempt=async(fromUser=false)=>{
          statusEl && (statusEl.textContent='');
          const release=acquireOverlay('dir-permission');
          try{
            const handle=await ensureDir({prompt:true, forceCheck:true, allowSchedule:false});
            if(handle){
              cleanup();
              hideOverlay();
              resolve();
              return;
            }
            if(statusEl){
              statusEl.textContent = fromUser
                ? 'ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ç«¯æœ«ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€Œè¨±å¯ã™ã‚‹ã€ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚'
                : 'éŸ³å£°ãƒ•ã‚©ãƒ«ãƒ€ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚ã€Œè¨±å¯ã‚’é–‹ãã€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚';
            }
            if(fromUser && laterBtn){
              laterBtn.hidden=false;
            }
          }catch(err){
            console.warn('dir permission attempt failed', err);
            if(statusEl){
              statusEl.textContent = fromUser
                ? 'ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'
                : 'ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã€Œè¨±å¯ã‚’é–‹ãã€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚';
            }
            if(fromUser && laterBtn){
              laterBtn.hidden=false;
            }
          }finally{
            release();
          }
        };
        const skip=()=>{
          cleanup();
          hideOverlay();
          resolve();
        };
        const onKey=ev=>{ if(ev.key==='Enter'){ ev.preventDefault(); attempt(true); } };
        const onAllow=()=>{ attempt(true); };
        function cleanup(){
          allowBtn.removeEventListener('click', onAllow);
          laterBtn?.removeEventListener('click', skip);
          overlay.removeEventListener('keydown', onKey);
        }
        showOverlay();
        allowBtn.addEventListener('click', onAllow);
        laterBtn?.addEventListener('click', skip);
        overlay.addEventListener('keydown', onKey);
        setTimeout(()=>{ attempt(false).catch(()=>{}); }, 0);
      });
    }else{
      await ensureDir({prompt:true, forceCheck:true, allowSchedule:false});
    }
  }

  // Settings modal
  if(el.cfgBtn && el.cfgModal && el.cfgUrl && el.cfgKey && el.cfgAudioBase){
    el.cfgBtn.addEventListener('click', ()=>{
      el.cfgUrl.value=CFG.apiUrl||'';
      el.cfgKey.value=CFG.apiKey||'';
      el.cfgAudioBase.value=CFG.audioBase||'./audio';
      refreshDirStatus();
      updateNotificationUi();
      el.cfgModal.style.display='flex';
    });
  }
  initNotificationSystem();
  if(el.cfgClose && el.cfgModal){
    el.cfgClose.addEventListener('click', ()=>{ el.cfgModal.style.display='none'; });
  }
  if(el.cfgSave && el.cfgModal && el.cfgUrl && el.cfgKey && el.cfgAudioBase){
    el.cfgSave.addEventListener('click', ()=>{
      CFG.apiUrl=(el.cfgUrl.value||'').trim();
      CFG.apiKey=(el.cfgKey.value||'').trim();
      CFG.audioBase=(el.cfgAudioBase.value||'').trim()||'./audio';
      saveCfg(CFG);
      if((CFG.apiUrl||'').trim()){
        for(const entry of PENDING_LOGS){
          entry.url=CFG.apiUrl.trim();
          entry.apiKey=(CFG.apiKey||'')||undefined;
        }
      } else {
        for(const entry of PENDING_LOGS){
          entry.url='';
          entry.apiKey=undefined;
        }
        applyRemoteStatus(null);
      }
      rememberPending();
      el.cfgModal.style.display='none';
      toast('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
      if((CFG.apiUrl||'').trim()){
        syncProgressAndStatus().catch(()=>{});
      }
    });
  }
  if(el.btnPickDir){
    el.btnPickDir.addEventListener('click', async()=>{
      if(!window.showDirectoryPicker){ toast('ã“ã®ç«¯æœ«ã¯ãƒ•ã‚©ãƒ«ãƒ€ãƒ”ãƒƒã‚«ãƒ¼éå¯¾å¿œ'); return; }
      try{
        const h=await showDirectoryPicker({mode:'read'});
        await saveDirHandle(h);
        DIR=h;
        dirNeedsGesture=false;
        refreshDirStatus();
        await ensureDir({prompt:true, forceCheck:true});
        refreshDirStatus();
        toast(dirNeedsGesture ? 'ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä¿å­˜ï¼ˆè¨±å¯å¾…ã¡ï¼‰' : 'ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
      }catch(e){
        if(e&&e.name!=='AbortError') toast('ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—');
      }
    });
  }
  if(el.btnClearDir){
    el.btnClearDir.addEventListener('click', async()=>{
      await clearDirHandle();
      DIR=null;
      dirNeedsGesture=false;
      dirPromptArmed=false;
      refreshDirStatus();
      toast('ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šã‚’è§£é™¤');
    });
  }
  function refreshDirStatus(){ if(!el.dirStatus) return; if(DIR){ el.dirStatus.textContent = dirNeedsGesture ? 'è¨±å¯å¾…ã¡' : 'ä¿å­˜æ¸ˆã¿'; } else { el.dirStatus.textContent = 'æœªè¨­å®š'; } }

  // Import audio (OPFS)
  if(el.btnImport && el.filePick){
    el.btnImport.addEventListener('click', ()=>{ el.filePick.click(); });
    el.filePick.addEventListener('change', async(ev)=>{
      const files=[...ev.target.files||[]];
      if(!files.length){ toast('ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ'); return; }
      try{
        if(!(navigator.storage&&navigator.storage.getDirectory)) throw new Error('OPFSæœªå¯¾å¿œ');
        const root=await navigator.storage.getDirectory();
        let ok=0;
        for(const f of files){
          const fh=await root.getFileHandle(f.name,{create:true});
          const w=await fh.createWritable();
          await w.write(f);
          await w.close();
          ok++;
        }
        toast(`${ok} ä»¶ã‚’OPFSã¸ä¿å­˜`);
      }catch(e){
        console.error(e);
        toast('OPFSå–ã‚Šè¾¼ã¿å¤±æ•—');
      }
    });
  }

  // GAS Bridge
  async function refreshRemoteStatus(){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return null;
    try{
      const payload={type:'status', apiKey:CFG.apiKey||undefined};
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'text/plain;charset=UTF-8'},body:JSON.stringify(payload)});
      if(!res.ok) throw new Error('status '+res.status);
      const json=await res.json();
      if(json && json.ok && json.status){
        applyRemoteStatus(json.status);
        return json.status;
      }
    }catch(err){ console.warn('refreshRemoteStatus', err); }
    return null;
  }

  async function syncProgressAndStatus(){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return null;
    try{ await flushPendingLogs(); }catch(err){ console.warn('syncProgressAndStatus', err); }
    return refreshRemoteStatus();
  }

  window.addEventListener('online', ()=>{
    flushPendingLogs().then(()=>refreshRemoteStatus()).catch(()=>{});
  });

  // Data
  const DATA_URL='./data/items.json';
  const ITEM_CACHE_NAME='items-v1';
  const ITEMS_BY_SECTION=new Map();
  let itemsLoadPromise=null;
  async function fetchJson(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(url+': '+r.status); return r.json(); }
  window.ALL_ITEMS=[]; let SRS_MAP=new Map();
  function rebuildSectionIndex(){
    ITEMS_BY_SECTION.clear();
    for(const it of window.ALL_ITEMS){
      const key=String((it&& (it.unit ?? it.sec ?? ''))||'').trim();
      if(!key) continue;
      if(!ITEMS_BY_SECTION.has(key)) ITEMS_BY_SECTION.set(key, []);
      ITEMS_BY_SECTION.get(key).push(it);
    }
  }
  function updateSectionOptions({preferSaved=false}={}){
    const sel=el.secSel;
    if(!sel) return;
    const saved=localStorage.getItem('secSel')||'';
    const desired=preferSaved ? saved : (sel.value || saved || '');
    const frag=document.createDocumentFragment();
    frag.appendChild(new Option('å…¨ä½“',''));
    const units=[...ITEMS_BY_SECTION.keys()].sort((a,b)=>{
      const na=+String(a).replace(/\D+/g,'')||0;
      const nb=+String(b).replace(/\D+/g,'')||0;
      if(na!==nb) return na-nb;
      return String(a).localeCompare(String(b));
    });
    for(const u of units){ frag.appendChild(new Option(u,u)); }
    sel.innerHTML='';
    sel.appendChild(frag);
    const target=units.includes(desired)?desired:'';
    sel.value=target;
    if(preferSaved && saved && !units.includes(saved)){
      localStorage.setItem('secSel','');
    }
    if(!target && !preferSaved){
      localStorage.setItem('secSel','');
    }
    updateHeaderStats();
  }
  function applyItemsData(items,{refreshPicker=false}={}){
    window.ALL_ITEMS=Array.isArray(items)?items.slice():[];
    rebuildSectionIndex();
    if(refreshPicker) updateSectionOptions();
    updateHeaderStats();
  }
  async function loadItemsOnce(url){
    let cache=null;
    if('caches' in window){
      try{ cache=await caches.open(ITEM_CACHE_NAME); }catch(_){ cache=null; }
    }
    let resp=cache?await cache.match(url):null;
    if(!resp){
      resp=await fetch(url,{cache:'no-cache'});
      if(!resp.ok) throw new Error(url+': '+resp.status);
      if(cache){
        try{ await cache.put(url, resp.clone()); }catch(_){ }
      }
    }
    const data=await resp.json();
    if(cache){
      fetch(url,{cache:'no-cache'}).then(async fresh=>{
        if(!fresh.ok) return;
        try{ await cache.put(url, fresh.clone()); }catch(_){ }
        const latest=await fresh.json();
        applyItemsData(latest,{refreshPicker:true});
      }).catch(()=>{});
    }
    return data;
  }
  async function ensureItemsLoaded(){
    if(window.ALL_ITEMS.length){
      if(!ITEMS_BY_SECTION.size) rebuildSectionIndex();
      return window.ALL_ITEMS;
    }
    if(!itemsLoadPromise){
      itemsLoadPromise=(async()=>{
        const data=await loadItemsOnce(DATA_URL);
        applyItemsData(data);
        return window.ALL_ITEMS;
      })().catch(err=>{ itemsLoadPromise=null; throw err; });
    }
    return itemsLoadPromise;
  }
  async function ensureDataLoaded(){
    await ensureItemsLoaded();
    if(!SRS_MAP.size){
      try{ const arr=await fetchJson('./data/srs.json'); const m=new Map(); for(const x of arr) m.set(x.id,x); SRS_MAP=m; }
      catch(_){ SRS_MAP=new Map(); }
    }
  }

  // Build section options (All/å˜ä¸€)
  function initSectionPicker(){
    updateSectionOptions({preferSaved:true});
    const sel=el.secSel;
    sel.onchange=()=>{
      localStorage.setItem('secSel', sel.value);
      rebuildAndRender(true);
    };
    const ordSaved=localStorage.getItem('orderSel')||'asc';
    el.orderSel.value=ordSaved;
    el.orderSel.onchange=()=>{
      localStorage.setItem('orderSel', el.orderSel.value);
      rebuildAndRender(true);
    };
    if(el.search){
      const saved=loadSearchQuery();
      if(saved){
        el.search.value=saved;
      }
      let lastAppliedSearch=currentSearchQuery();
      let searchTimer=null;
      const resetSessionForSearch=()=>{
        if(sessionActive || sessionStarting){
          stopAudio();
          if(recogOn){
            stopRec().catch(()=>{});
          }
          setMicState(false);
          sessionActive=false;
          sessionStarting=false;
        }
      };
      const applySearchChange=(fromChange=false)=>{
        if(searchTimer){
          clearTimeout(searchTimer);
          searchTimer=null;
        }
        const trimmed=currentSearchQuery();
        if(fromChange && el.search.value!==trimmed){
          el.search.value=trimmed;
        }
        saveSearchQuery(trimmed);
        if(trimmed===lastAppliedSearch){
          return;
        }
        lastAppliedSearch=trimmed;
        updateHeaderStats();
        resetSessionForSearch();
        lastEmptySearchToast='';
        rebuildAndRender(true,{autoStart:false});
      };
      const scheduleSearchChange=()=>{
        if(searchTimer){
          clearTimeout(searchTimer);
        }
        searchTimer=setTimeout(()=>{
          applySearchChange(false);
        }, 220);
      };
      el.search.addEventListener('input', ()=>{
        saveSearchQuery(el.search.value.trim());
        scheduleSearchChange();
      });
      el.search.addEventListener('change', ()=>{
        applySearchChange(true);
      });
    }
    initLevelFilterUI();
  }

  function getRandomIndex(maxExclusive){
    if(maxExclusive<=0) return 0;
    const cryptoObj = (typeof window!=='undefined' && window.crypto && window.crypto.getRandomValues) ? window.crypto : null;
    if(!cryptoObj) return Math.floor(Math.random()*maxExclusive);
    const randArr=new Uint32Array(1);
    const limit=Math.floor(0x100000000/maxExclusive)*maxExclusive;
    let val;
    do{
      cryptoObj.getRandomValues(randArr);
      val=randArr[0];
    }while(val>=limit);
    return val%maxExclusive;
  }
  function shuffledCopy(arr){
    if(!Array.isArray(arr)||arr.length<=1) return Array.isArray(arr)?arr.slice():[];
    const copy=arr.slice();
    for(let i=copy.length-1;i>0;i--){
      const j=getRandomIndex(i+1);
      if(i!==j){
        [copy[i],copy[j]]=[copy[j],copy[i]];
      }
    }
    return copy;
  }
  function buildQueue(){
    const sec=el.secSel.value;
    const order=el.orderSel.value;
    const baseItems=sec ? (ITEMS_BY_SECTION.get(sec)||[]) : window.ALL_ITEMS;
    let items=Array.isArray(baseItems) ? baseItems.filter(Boolean) : [];
    const levels=activeLevelArray();
    if(levels.length && levels.length<LEVEL_CHOICES.length){
      const levelSet=new Set(levels);
      items=items.filter(x=>levelSet.has(lastRecordedLevel(x.id)));
    }
    const query=currentSearchQuery().toLowerCase();
    if(query){
      items=items.filter(it=>{
        const en=String(it.en||'').toLowerCase();
        const ja=String(it.ja||'').toLowerCase();
        const tags=String(it.tags||'').toLowerCase();
        return en.includes(query) || ja.includes(query) || tags.includes(query);
      });
    }
    if(order==='rnd'){
      items=shuffledCopy(items);
    }else{
      items=items.slice().sort((a,b)=>{
        const na=+String(a.unit||'').replace(/\D+/g,'')||0;
        const nb=+String(b.unit||'').replace(/\D+/g,'')||0;
        if(na!==nb) return na-nb;
        return String(a.id).localeCompare(String(b.id));
      });
    }
    return items.map(it=>({ id:it.id,en:it.en,ja:it.ja,tags:it.tags||'',chunks_json:it.chunks||'[]',audio_fn:it.audio_fn||'' }));
  }

  // Audio resolve: DIR (folder) -> OPFS -> base URL
  const audioUrlCache=new Map();
  async function resolveFromDir(name){ try{ const d=await ensureDir(); if(!d||!name) return ''; const fh=await d.getFileHandle(name).catch(()=>null); if(!fh) return ''; const f=await fh.getFile(); return URL.createObjectURL(f); }catch(_){ return ''; } }
  async function resolveFromOPFS(name){ if(!name) return ''; try{ if(!(navigator.storage&&navigator.storage.getDirectory)) return ''; const root=await navigator.storage.getDirectory(); const fh=await root.getFileHandle(name).catch(()=>null); if(!fh) return ''; const file=await fh.getFile(); return URL.createObjectURL(file); }catch(_){ return ''; } }
  async function resolveAudioUrl(name){ if(!name) return ''; if(audioUrlCache.has(name)) return audioUrlCache.get(name); let url=await resolveFromDir(name); if(!url) url=await resolveFromOPFS(name); if(!url){ const base=(CFG.audioBase||'./audio').replace(/\/$/,''); url= base + '/' + encodeURI(name); } audioUrlCache.set(name,url); return url; }

  async function primeAudio(item, knownUrl){
    if(!item||!item.audio_fn) return;
    let url=knownUrl;
    if(!url){
      url=await resolveAudioUrl(item.audio_fn);
    }
    if(!url) return;
    if(PREFETCH_POOL.has(url)) return PREFETCH_POOL.get(url).promise;
    const prefetch=new Audio();
    prefetch.preload='auto';
    prefetch.crossOrigin='anonymous';
    prefetch.src=url;
    const promise=waitForAudioReady(prefetch, 4000).finally(()=>{
      try{ prefetch.pause?.(); }catch(_){ }
    });
    try{ prefetch.load?.(); }catch(_){ }
    rememberPrefetch(url,{audio:prefetch,promise});
    return promise;
  }

  // Render & navigation
  function stopAudio(){ resumeAfterMicStart=false; clearResumeTimer(); try{audio.pause();}catch(_){ } audio.currentTime=0; }
  async function tryPlayAudio({userInitiated=false, resetPosition=false}={}){
    if(!audio?.dataset?.srcKey){
      if(userInitiated) toast('éŸ³å£°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      return false;
    }
    if(resetPosition){
      try{ audio.currentTime=0; }catch(_){ }
    }
    try{
      const playPromise=audio.play();
      if(playPromise && typeof playPromise.then==='function'){
        await playPromise;
      }
      if(userInitiated){
        autoPlayUnlocked=true;
      }
      return true;
    }catch(err){
      console.warn('audio play failed', err);
      if(userInitiated){
        let reason='éŸ³å£°ã‚’å†ç”Ÿã§ãã¾ã›ã‚“ã§ã—ãŸ';
        if(err){
          if(err.name==='NotAllowedError'){ reason='ãƒ–ãƒ©ã‚¦ã‚¶ã«ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ç«¯æœ«ã®éŸ³é‡è¨­å®šãªã©ã‚’ç¢ºèªã—ã¦å†åº¦ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„'; }
          else if(err.message||err.name){ reason=err.message||err.name; }
        }
        toast(`éŸ³å£°ã‚’å†ç”Ÿã§ãã¾ã›ã‚“: ${reason}`);
      }
      return false;
    }
  }
  function resetResult(){ updateMatch(null); }
  function resetTranscript(){ qs('#transcript').innerHTML=''; }
  function toggleJA(){ advanceHintStage(); }

  function showIdleCard(){
    sessionActive=false;
    sessionStarting=false;
    stopAudio();
    clearAudioSource();
    autoPlayUnlocked=false;
    updatePlayVisualState();
    updatePlayButtonAvailability();
    if(el.play){ el.play.disabled=true; }
    const query=currentSearchQuery();
    const hasQueue=QUEUE.length>0;
    const emptyWithSearch=!!query && !hasQueue;
    el.en.textContent = hasQueue ? 'å‡ºé¡Œã‚’æº–å‚™ã—ã¦ã„ã¾ã™â€¦' : (emptyWithSearch ? 'æ¤œç´¢çµæœãŒã‚ã‚Šã¾ã›ã‚“' : 'å‡ºé¡Œã§ãã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“');
    el.en.classList.remove('concealed');
    clearHighlight();
    el.ja.textContent = 'â€”';
    el.ja.style.display = 'none';
    el.chips.innerHTML = '';
    currentItem=null;
    currentEnHtml='';
    hintStage=BASE_HINT_STAGE;
    maxHintStageUsed=BASE_HINT_STAGE;
    refreshLevelDisplay(null);
    cardStart = now();
    sessionStart = 0;
    failCount = 0;
    resetResult();
    resetTranscript();
    updateAttemptInfo();
    hideNextCta();
    setMicState(false);
    el.mic.disabled = true;
    el.next.hidden = true;
    el.pbar.value = 0;
    el.footer.textContent = hasQueue ? 'æº–å‚™ãŒæ•´ã„æ¬¡ç¬¬ã€è‡ªå‹•ã§é–‹å§‹ã—ã¾ã™' : (emptyWithSearch ? 'æ¤œç´¢æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“' : 'ã‚­ãƒ¥ãƒ¼ãŒç©ºã§ã™');
    if(emptyWithSearch){
      if(lastEmptySearchToast!==query){
        toast('æ¤œç´¢æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹é …ç›®ãŒã‚ã‚Šã¾ã›ã‚“');
        lastEmptySearchToast=query;
      }
    }else{
      lastEmptySearchToast='';
    }
    updateHeaderStats();
  }

  async function render(i, autoPlay=false){
    const releaseCardLoad = acquireOverlay('card-load');
    try{
      stopAudio();
      const it=QUEUE[i];
      if(!it){
        el.footer.textContent='ã‚­ãƒ¥ãƒ¼ãŒç©ºã§ã™';
        clearAudioSource();
        return;
      }
      currentItem=it;
      currentEnHtml=spanify(it.en);
      el.en.classList.remove('concealed');
      el.en.innerHTML=currentEnHtml;
      clearHighlight();
      el.ja.textContent=it.ja;
      el.chips.innerHTML='';
      (it.tags||'').split(',').filter(Boolean).forEach(t=>{ const s=document.createElement('span'); s.className='chip'; s.textContent=t.trim(); el.chips.appendChild(s); });
      const levelInfo=getLevelInfo(it.id);
      refreshLevelDisplay(levelInfo);
      setHintStage(BASE_HINT_STAGE,{reset:true});
      const needsResolveLoader = !!(it.audio_fn && !audioUrlCache.has(it.audio_fn));
      let url='';
      const releaseResolve = needsResolveLoader ? acquireOverlay('audio-resolve') : null;
      try{
        url=await resolveAudioUrl(it.audio_fn);
      }finally{
        releaseResolve?.();
      }
      if(url){
        const releasePrepare = acquireOverlay('audio-prepare');
        try{
          await setAudioSource(url);
          if(audio.readyState<2){
            const retryPrime=primeAudio(it, url);
            if(retryPrime){
              try{ await retryPrime; }catch(err){ console.warn('primeAudio retry failed', err); }
            }
            await setAudioSource(url,{timeout:4000, forceReload:true});
            if(audio.readyState<2){
              console.warn('Audio not ready after retry', it && it.id, url);
            }
          }
        }finally{
          releasePrepare();
        }
      }else{
        clearAudioSource();
      }
      if(el.play){ el.play.disabled=!url; }
      cardStart=now();
      resetResult();
      resetTranscript();
      lastMatchEval=null;
      failCount=0;
      updateAttemptInfo();
      hideNextCta();
      setMicState(false);
      el.mic.disabled=false;
      primeAudio(QUEUE[i+1]);
      primeAudio(QUEUE[i-1]);
      if(autoPlay&&url){
        try{
          await tryPlayAudio({userInitiated:false, resetPosition:true});
        }catch(err){
          console.warn('auto play failed', err);
        }
      }
    }finally{
      releaseCardLoad();
    }
  }

  async function rebuildAndRender(resetIndex=false, {autoStart=true, autoPlay=false}={}){
    QUEUE=buildQueue();
    el.pbar.max=Math.max(1, QUEUE.length);
    hideNextCta();
    if(resetIndex){
      idx=-1;
      showIdleCard();
      if(autoStart && QUEUE.length){
        setTimeout(()=>{
          if(!sessionActive && !sessionStarting){
            startSession(autoPlay);
          }
        }, 0);
      }
      return;
    }
    if(!sessionActive){
      showIdleCard();
      return;
    }
    if(!QUEUE.length){
      showIdleCard();
      return;
    }
    idx=Math.max(0, Math.min(idx, QUEUE.length-1));
    render(idx,false);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
    updateHeaderStats();
  }

  function advanceToNextSection(){
    if(!el.secSel) return false;
    const options=[...el.secSel.options];
    if(!options.length) return false;
    const currentValue=el.secSel.value;
    const currentIndex=options.findIndex(opt=>opt.value===currentValue);
    if(currentIndex<0 || currentIndex>=options.length-1) return false;
    if(currentIndex===0 && currentValue==='') return false;
    const nextOpt=options[currentIndex+1];
    const nextValue=nextOpt.value;
    el.secSel.value=nextValue;
    localStorage.setItem('secSel', nextValue);
    hideNextCta();
    const label=nextOpt.textContent||nextOpt.label||nextValue||'æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³';
    toast(`ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œ${label}ã€ã¸é€²ã¿ã¾ã™`);
    rebuildAndRender(true,{autoPlay:true})
      .then(()=>{
        if(!QUEUE.length){
          el.footer.textContent='æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«å‡ºé¡ŒãŒã‚ã‚Šã¾ã›ã‚“';
        }
      })
      .catch(err=>{ console.error(err); toast('æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'); });
    return true;
  }

  async function nextCard(first=false, autoPlay=false){
    if(!QUEUE.length){ el.footer.textContent='ã‚­ãƒ¥ãƒ¼ãŒç©ºã§ã™'; clearAudioSource(); stopAudio(); return; }
    if(!sessionActive) return;
    if(!first && idx>=QUEUE.length-1){
      if(advanceToNextSection()) return;
      toast('æœ€å¾Œã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¾ã§å®Œäº†ã—ã¾ã—ãŸ');
      return;
    }
    idx = first? 0 : Math.min(QUEUE.length-1, idx+1);
    await render(idx, autoPlay && autoPlayUnlocked);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
    updateHeaderStats();
  }
  async function prevCard(autoPlay=false){
    if(!QUEUE.length) return;
    if(!sessionActive) return;
    idx=Math.max(0, idx-1);
    await render(idx, autoPlay && autoPlayUnlocked);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
    updateHeaderStats();
  }

  async function startSession(autoPlay=false){
    if(sessionActive || sessionStarting) return;
    if(!QUEUE.length){ showIdleCard(); return; }
    sessionStarting=true;
    try{
      if((CFG.apiUrl||'').trim()){
        syncProgressAndStatus().catch(err=>{ console.warn('startSession status', err); });
      }
      await ensureDir();
      sessionActive=true;
      sessionStart=now();
      idx=-1;
      el.mic.disabled=false;
      try{
        await nextCard(true, autoPlay);
      }catch(err){
        sessionActive=false;
        throw err;
      }
    }finally{
      sessionStarting=false;
    }
  }

  // Gestures
  let touchStart=null; const TH=60;
  el.card.addEventListener('touchstart',(ev)=>{ if(!sessionActive){ touchStart=null; return; } if(ev.touches?.length!==1) return; const t=ev.touches[0]; touchStart={x:t.clientX,y:t.clientY}; },{passive:true});
  el.card.addEventListener('touchend',(ev)=>{ if(!touchStart) return; if(!sessionActive){ touchStart=null; return; } const end=ev.changedTouches[0]; const dx=end.clientX-touchStart.x, dy=end.clientY-touchStart.y; if(Math.abs(dx)>Math.abs(dy) && Math.abs(dx)>TH){ if(dx>0) prevCard(true); else nextCard(false,true); } else if(Math.abs(dy)>TH && dy<0){ toggleJA(); } touchStart=null; },{passive:true});
  el.en.addEventListener('click', async ()=>{ if(!sessionActive){ await startSession(false); } });
  el.en.addEventListener('dblclick', ()=>{ if(!sessionActive) return; toggleJA(); });
  el.next.onclick=()=> nextCard(false,true);
  el.play.addEventListener('click', async ()=>{
    if(sessionStarting) return;
    if(!sessionActive){ await startSession(false); }
    if(sessionStarting) return;
    if(!sessionActive){ return; }
    if(!audio.dataset.srcKey){ toast('éŸ³å£°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
    if(audio.paused){
      const shouldReset = audio.ended || audio.currentTime<=0.05;
      await tryPlayAudio({userInitiated:true, resetPosition:shouldReset});
    }else{
      resumeAfterMicStart=false;
      clearResumeTimer();
      audio.pause();
    }
  });

  // ASRï¼ˆæ”¹è‰¯ï¼šé‡è¤‡æŠ‘åˆ¶ãƒ»ä¸Šé™ãƒ»å¤šé‡ä¸€è‡´é˜²æ­¢ï¼‰
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let stableText=''; // ç¢ºå®šãƒ†ã‚­ã‚¹ãƒˆï¼ˆè©•ä¾¡ã¯ã“ã¡ã‚‰ã®ã¿ä½¿ç”¨ï¼‰
  let lastMatchEval=null;

  function clearHighlight(){
    document.querySelectorAll('.en .tok').forEach(sp=>{
      sp.classList.remove('hit');
      sp.classList.remove('miss');
    });
  }

  function matchAndHighlight(refText, hypText){
    const refTokens = toks(refText);
    const hypTokensRaw = toks(hypText);
    const hypTokens = dedupeRuns(hypTokensRaw);

    function evaluateWindow(tokens){
      const remain=new Map();
      const matchedCounts=new Map();
      const matchedWords=[];
      for(const w of refTokens){ remain.set(w, (remain.get(w)||0)+1); }
      tokens.forEach((h,idx)=>{
        if(!h) return;
        let matchKey='';
        if(remain.get(h)>0){ matchKey=h; }
        else{
          for(const [k,c] of remain){ if(c>0 && approxWithin1(k,h)){ matchKey=k; break; } }
        }
        if(matchKey){
          remain.set(matchKey, remain.get(matchKey)-1);
          matchedCounts.set(matchKey, (matchedCounts.get(matchKey)||0)+1);
          matchedWords.push(matchKey);
        }
      });
      const missing=[];
      for(const [w,c] of remain){ for(let i=0;i<(c||0);i++) missing.push(w); }
      const matchedCount=matchedWords.length;
      const recall = refTokens.length? matchedCount/refTokens.length : 1;
      const precision = tokens.length? matchedCount/tokens.length : 1;
      return {tokens, recall, precision, missing, matchedWords, matchedCount, matchedCounts};
    }

    function cloneCountMap(map){
      const out=new Map();
      if(map){ for(const [k,v] of map) out.set(k,v); }
      return out;
    }

    let best=evaluateWindow(hypTokens);
    best.start=0; best.end=hypTokens.length;
    const refLen=refTokens.length;
    const slack = Math.max(4, Math.ceil(refLen*0.5));
    const minLen = Math.max(1, refLen ? Math.max(1, refLen - slack) : 1);
    const maxLen = Math.max(
      minLen,
      Math.min(hypTokens.length, Math.max(refLen + slack, refLen * 2 || 1))
    );
    for(let start=0; start<hypTokens.length; start++){
      for(let len=minLen; len<=maxLen; len++){
        const end=start+len;
        if(end>hypTokens.length) break;
        const slice=hypTokens.slice(start,end);
        const evalRes=evaluateWindow(slice);
        evalRes.start=start; evalRes.end=end;
        const bestScore=calcMatchScore(refLen, best.recall, best.precision);
        const candScore=calcMatchScore(refLen, evalRes.recall, evalRes.precision);
        if(candScore>bestScore || (candScore===bestScore && (
          evalRes.recall>best.recall || (evalRes.recall===best.recall && (
            evalRes.precision>best.precision || (evalRes.precision===best.precision && (
              Math.abs((evalRes.tokens?.length||0)-refLen) < Math.abs((best.tokens?.length||0)-refLen) || (
                Math.abs((evalRes.tokens?.length||0)-refLen) === Math.abs((best.tokens?.length||0)-refLen) && (evalRes.start||0)<=(best.start||0)
              )
            ))
          ))
        ))){
          best=evalRes;
        }
      }
    }

    const spans=[...document.querySelectorAll('.en .tok')].filter(s=>s.dataset.w);
    const matchMap=cloneCountMap(best.matchedCounts);
    for(const sp of spans){
      const wTokens=toks(sp.dataset.w);
      if(!wTokens.length){ sp.classList.remove('hit'); sp.classList.add('miss'); continue; }
      const reserved=[];
      let hit=true;
      for(const tok of wTokens){
        let matchKey='';
        if((matchMap.get(tok)||0)>0){
          matchKey=tok;
        }else{
          for(const [k,c] of matchMap){
            if(c>0 && approxWithin1(k,tok)){ matchKey=k; break; }
          }
        }
        if(matchKey){
          matchMap.set(matchKey, matchMap.get(matchKey)-1);
          reserved.push(matchKey);
        }else{
          hit=false;
          break;
        }
      }
      if(!hit){
        for(const key of reserved){ matchMap.set(key, (matchMap.get(key)||0)+1); }
      }
      sp.classList.toggle('hit', hit);
      sp.classList.toggle('miss', !hit);
    }

    return {
      recall: best.recall,
      precision: best.precision,
      matched: best.matchedWords,
      missing: best.missing,
      refCount: refLen,
      hypTokens: best.tokens,
      transcript: (best.tokens||[]).join(' '),
      source: (hypText||'').trim()
    };
  }

  function showTranscriptInterim(text){ qs('#transcript').innerHTML=`<span class="interim">${text}</span>`; }
  function showTranscriptFinal(text){ qs('#transcript').textContent=text; }

  function startRec(){
    if(!SR){ toast('ã“ã®ç«¯æœ«ã§ã¯éŸ³å£°èªè­˜ãŒä½¿ãˆã¾ã›ã‚“'); return; }
    if(el.mic.disabled) return;
    if(recogOn) return;
    hideNextCta();
    const shouldResume = audio && !audio.paused && !audio.ended;
    resumeAfterMicStart = shouldResume;
    clearResumeTimer();
    recog = new SR();
    recog.lang = 'en-US';
    recog.continuous = true;
    recog.interimResults = true;
    recog.maxAlternatives = 1;

    stableText = '';
    lastMatchEval=null;
    recogOn = true;
    setMicState(true);
    playTone('start');
    resetTranscript();
    clearHighlight();

    try{ recog.start(); }catch(_){ }

    if(shouldResume && audio?.src){
      audio.play().catch(()=>{});
    }

    recog.onresult = (ev)=>{
      let interim = '';
      for(let i=ev.resultIndex; i<ev.results.length; i++){
        const r = ev.results[i];
        const t = r[0].transcript || '';
        if(r.isFinal){
          // å°¾éƒ¨ã®ã¿è¿½åŠ ã—ã¦ã„ãï¼ˆéå‰°è“„ç©ã‚’é˜²æ­¢ï¼‰
          stableText = appendStableFinal(stableText, t);
          const trimmedStable = stableText.trim();
          const refItem = QUEUE[idx];
          const refText = refItem ? refItem.en : el.en.textContent;
          const m = matchAndHighlight(refText, trimmedStable);
          const normalized = (m.transcript && m.transcript.trim()) || trimmedStable;
          stableText = normalized;
          showTranscriptFinal(normalized);
          lastMatchEval = Object.assign({}, m, { source: normalized, transcript: normalized });
          const score = calcMatchScore(m.refCount, m.recall, m.precision);
          updateMatch(score);
        }else{
          interim = t;
        }
      }
      if(interim) showTranscriptInterim(interim); // ç”»é¢è¡¨ç¤ºã ã‘ãƒ»è©•ä¾¡ã«ã¯ä½¿ã‚ãªã„
    };

    recog.onerror = (e)=>{ console.warn(e); toast('ASRã‚¨ãƒ©ãƒ¼: '+(e && e.error || '')); playTone('fail'); setMicState(false); resumeAfterMicStart=false; clearResumeTimer(); recogOn=false; el.mic.disabled=false; recog=null; };
    recog.onend = ()=>{ if(recogOn) stopRec(); else setMicState(false); };
  }

  async function stopRec(){
    if(!recogOn) return;
    recogOn=false;
    resumeAfterMicStart=false;
    clearResumeTimer();
    try{ recog && recog.stop && recog.stop(); }catch(_){ }
    setMicState(false);

    const it = QUEUE[idx]; if(!it) return;
    const hyp = stableText.trim();
    const refItem = QUEUE[idx];
    const refText = refItem ? refItem.en : el.en.textContent;
    const matchInfo = (lastMatchEval && lastMatchEval.source === hyp) ? lastMatchEval : matchAndHighlight(refText, hyp);
    lastMatchEval = matchInfo;
    const { recall, precision, matched, missing, refCount, hypTokens, transcript } = matchInfo;
    const matchRate = calcMatchScore(refCount, recall, precision);
    updateMatch(matchRate);

    const prevInfoSnapshot = getLevelInfo(it.id);
    let prevBest = Number(prevInfoSnapshot?.best||0);
    if(!Number.isFinite(prevBest) || prevBest<=0){
      prevBest = Number(prevInfoSnapshot?.last||0) || 0;
    }
    const stageUsed = maxHintStageUsed;
    const levelCandidate = evaluateLevel(matchRate, stageUsed);
    const levelInfo = updateLevelInfo(it.id, levelCandidate, matchRate, stageUsed);
    const levelInfoBest = Number(levelInfo?.best||0) || Number(levelInfo?.last||0) || levelCandidate;
    const gainedLevel5 = prevBest<5 && levelInfoBest>=5;
    refreshLevelDisplay(levelInfo);
    updateHeaderStats();

    const pct=Math.max(0, Math.round((matchRate||0)*100));
    const levelLabel = levelInfo ? `Lv${levelInfo.last || levelInfo.best || levelCandidate}` : `Lv${levelCandidate}`;
    const bestLabel = levelInfo && levelInfo.best>levelInfo.last ? ` (æœ€é«˜${levelInfo.best})` : '';

    const pass = matchRate >= 0.70;
    if(pass){
      failCount=0;
      playTone('success');
      showNextCta();
      el.footer.textContent = `ä¸€è‡´ç‡${pct}% ${levelLabel}${bestLabel}ï¼ã€Œæ¬¡ã¸ã€ã§é€²ã¿ã¾ã—ã‚‡ã†`;
      if(levelCandidate>=4 && stageUsed<=0){
        toast(`ç´ æ™´ã‚‰ã—ã„ï¼${levelLabel}é”æˆ`, 1600);
      }else{
        toast('Great! åˆæ ¼ã§ã™', 1600);
      }
      recordStudyProgress({pass:true, newLevel5:gainedLevel5});
    }else{
      failCount++;
      playTone('fail');
      if(failCount>=FAIL_LIMIT){
        el.footer.textContent = `3å›å¤±æ•—ã€‚${levelLabel}ã§æ¬¡ã¸é€²ã¿ã¾ã™`;
        toast('ä¸åˆæ ¼ã§æ¬¡ã¸é€²ã¿ã¾ã™', 1600);
        el.mic.disabled=true;
        setTimeout(()=>{ hideNextCta(); nextCard(false,true); }, 900);
      }else{
        el.footer.textContent = `ä¸€è‡´ç‡${pct}%ï¼š${levelLabel}${bestLabel} ç¶­æŒã®ãŸã‚å†æŒ‘æˆ¦ (${failCount}/${FAIL_LIMIT})`;
        toast('70%æœªæº€ã€‚ã‚‚ã†ä¸€åº¦ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼', 1600);
      }
    }
    updateAttemptInfo();

    // Persist the locally-tracked level information to the GAS spreadsheet log as well.
    const payload = {
      ts: new Date().toISOString(), id: it.id, mode: 'read',
      wer: +(1-recall).toFixed(3), cer: +(1-precision).toFixed(3),
      latency_ms: 0,
      words_spoken: (hypTokens||toks(hyp)).length,
      transcript: transcript || hyp,
      transcript_raw: hyp,
      matched_tokens_json: JSON.stringify(matched),
      missing_tokens_json: JSON.stringify(missing),
      recall:+recall.toFixed(3), precision:+precision.toFixed(3),
      match:+(matchRate||0).toFixed(3),
      hint_stage:stageUsed,
      level_last:levelInfo?.last ?? levelCandidate,
      level_best:levelInfo?.best ?? levelCandidate
    };
    try{ await sendLog('speech', payload); }catch(_){ }
    if(!pass && failCount<FAIL_LIMIT){ el.mic.disabled=false; }
    recog=null;
  }

  el.mic.onclick=()=>{ if(!recogOn) startRec(); else stopRec(); };
  // Boot
  (async()=>{
    const releaseBoot=acquireOverlay('boot');
    try{
      await ensureDir({prompt:true, forceCheck:true, allowSchedule:false});
      if(DIR && dirNeedsGesture){
        await gateDirPermissionBeforeBoot();
      }
      await ensureDataLoaded();
      updateHeaderStats();
      initSectionPicker();
      refreshDirStatus();
      await rebuildAndRender(true);
      syncProgressAndStatus().catch(()=>{});
    }catch(e){
      console.error(e);
      toast('åˆæœŸåŒ–å¤±æ•—: '+(e&&e.message||e));
    }finally{
      releaseBoot();
    }
  })();
})();
</script>

<!-- â˜… Service Worker ç™»éŒ²ï¼ˆæœ€å°ï¼‰ -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    });
  }
</script>
</body>
</html>
