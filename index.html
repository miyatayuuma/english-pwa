<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>英語学習（範囲UI＋ASR・安定改良版）</title>
  <!-- ★ PWA 追加 -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b0e1a" />
  <style>
    :root{ --bg:#0b0e1a; --panel:rgba(20,24,36,.65); --bd:rgba(255,255,255,.12); --txt:#e6e8ef; --muted:#aeb5c6; --accent:#62d5ff; --good:#46d37f; --bad:#ff6b6b; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,"Segoe UI","Noto Sans JP",sans-serif}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto auto 1fr auto}

    header{padding:10px 12px;display:flex;gap:12px;align-items:center;background:var(--panel);border-bottom:1px solid var(--bd)}
    .stat{display:flex;gap:6px;align-items:baseline;font-size:14px;color:var(--muted)} .stat b{font-size:18px;color:var(--txt)} .grow{flex:1}
    .icon{width:38px;height:38px;border-radius:999px;border:1px solid var(--bd);display:grid;place-items:center;cursor:pointer;background:#111726}

    /* 範囲UI（ネイティブセレクト中心＝モバイル最適） */
    #rangeBar{display:flex;gap:8px;align-items:center;padding:8px 12px;background:rgba(20,24,36,.5);border-bottom:1px solid rgba(255,255,255,.12);overflow:auto}
    select, .switch{background:#111726;border:1px solid var(--bd);color:var(--txt);border-radius:12px;padding:8px}
    .switch{display:flex;gap:8px;align-items:center}

    main{padding:12px;overflow:auto}
    .card{max-width:840px;margin:0 auto;background:var(--panel);border:1px solid var(--bd);border-radius:18px;padding:16px;min-height:50vh;display:flex;flex-direction:column;gap:12px;touch-action:manipulation}
    .chips{display:flex;gap:6px;flex-wrap:wrap}
    .en{font-size:22px;line-height:1.6;word-break:normal;overflow-wrap:break-word;white-space:normal}
    .en.concealed{display:flex;align-items:center;justify-content:center;min-height:120px;color:var(--muted);font-size:18px;font-style:italic;text-align:center}
    .hint-placeholder{opacity:.7}
    .en .tok{padding:0 2px;border-radius:4px}
    .en .hit{background:rgba(70,211,127,.18);border-bottom:1px solid rgba(70,211,127,.6)}
    .en .miss{background:rgba(255,107,107,.15);border-bottom:1px dashed rgba(255,107,107,.7)}
    .ja{font-size:16px;color:var(--muted);display:none}
    .weak-words{display:flex;gap:6px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .weak-words .word{padding:4px 8px;background:rgba(255,255,255,.08);border-radius:999px;border:1px solid rgba(255,255,255,.12);cursor:pointer;transition:all .2s ease}
    .weak-words .word.active{border-color:var(--accent);color:var(--accent);background:rgba(98,213,255,.12)}
    .weak-words .label{padding:4px 0;font-weight:600}
    #transcript{min-height:1.6em}
    #transcript .interim{opacity:.6}

    .kpi{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:12px;flex-wrap:wrap}
    .kpi .val{color:var(--txt);font-weight:600}
    .match-val{font-size:18px;transition:color .3s ease}
    .match-good{color:var(--good)}
    .match-mid{color:#f6c863}
    .match-bad{color:var(--bad)}
    .attempt-info{font-size:12px;color:var(--muted);transition:color .3s ease}
    .attempt-info.alert{color:var(--bad)}

    footer{border-top:1px solid var(--bd);padding:8px 12px;display:flex;gap:10px;align-items:center;background:var(--panel)}
    progress{width:160px;height:10px}
    .btn{border:1px solid var(--bd);border-radius:12px;background:#111726;color:var(--txt);padding:10px 14px;cursor:pointer}
    .btn.ok{background:#10331f;border-color:#1f5c38}
    .btn.ng{background:#331717;border-color:#5c2929}
    #btnMic{width:72px;height:72px;font-size:22px;border-radius:999px;background:#1a2134;border-color:#2a3753;display:grid;place-items:center;font-weight:600;margin-left:auto;margin-right:auto;transition:transform .2s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease}
    #btnMic.recording{background:var(--accent);border-color:#7de4ff;box-shadow:0 0 0 0 rgba(98,213,255,.55);animation:micPulse 1.4s ease-in-out infinite}
    #btnMic:disabled{opacity:.35;cursor:not-allowed;animation:none;box-shadow:none}
    #btnMic .micIcon{font-size:28px}
    @keyframes micPulse{0%{transform:scale(1);box-shadow:0 0 0 0 rgba(98,213,255,.55);}70%{transform:scale(1.05);box-shadow:0 0 0 16px rgba(98,213,255,0);}100%{transform:scale(1);box-shadow:0 0 0 0 rgba(98,213,255,0);}}
    .next-cta{margin-top:10px;display:block;width:100%;font-size:18px;padding:14px;border-radius:14px;background:#10331f;border-color:#1f5c38;font-weight:600}

    /* 設定モーダル */
    #cfgModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:9999}
    #cfgBox{width:min(560px,92%);background:#111726;border:1px solid var(--bd);border-radius:14px;padding:16px}
    #cfgBox h3{margin:0 0 8px 0}
    #cfgBox label{display:block;margin:10px 0}
    #cfgBox input[type="text"], #cfgBox input[type="url"]{width:100%;padding:8px;border-radius:10px;border:1px solid var(--bd);background:#0c1221;color:var(--txt)}
    #cfgBox .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    #toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#0f1422;border:1px solid #24304a;color:#b7c0d6;border-radius:10px;padding:8px 12px;z-index:99999;display:none}
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="stat">残 <b id="statLeft">0</b></div>
    <div class="stat">分 <b id="statMin">0</b></div>
    <div class="stat">streak <b id="statStreak">0</b></div>
    <div class="grow"></div>
    <div id="btnCfg" class="icon" title="設定">⚙️</div>
  </header>

  <!-- 出題範囲（ネイティブピッカー） -->
  <div id="rangeBar">
    <label>セクション
      <select id="secSel"></select>
    </label>
    <label>並び
      <select id="orderSel">
        <option value="asc">昇順</option>
        <option value="rnd">ランダム</option>
      </select>
    </label>
    <label class="switch"><input id="chkOnlyWeak" type="checkbox"> 未習得のみ</label>
  </div>

  <main>
    <section class="card" id="card" aria-live="polite">
      <div class="chips" id="chips"></div>
      <div id="weakWords" class="weak-words" hidden></div>
      <div id="enText" class="en">タップで再生 / ダブルタップで和訳</div>
      <div id="jaText" class="ja">—</div>
      <div id="transcript" class="muted"></div>

      <div class="kpi">
        <div>一致率 <span class="val match-val" id="valMatch">—</span></div>
        <div>Lv <span class="val" id="valLevel">—</span></div>
        <div id="attemptInfo" class="attempt-info"></div>
      </div>

      <div style="display:flex;gap:8px">
        <button class="btn ok" data-eval="ok">◯ 得意</button>
        <button class="btn ng" data-eval="ng">× 苦手</button>
      </div>
      <button id="btnMic" class="btn" type="button" aria-label="マイク開始/停止"><span class="micIcon">🎤</span></button>
      <button id="btnNext" class="btn next-cta" type="button" hidden>次へ</button>
    </section>
  </main>

  <footer>
    <progress id="pbar" value="0" max="1"></progress>
    <span id="footerInfo" class="muted">左右スワイプ：戻る/進む　上：ヒント（英文→和訳）</span>
    <div class="grow"></div>
  </footer>
</div>

<audio id="player" preload="auto" crossorigin="anonymous"></audio>
<div id="toast"></div>

<!-- 設定モーダル -->
<div id="cfgModal">
  <div id="cfgBox">
    <h3>接続設定</h3>
    <label>GAS Web App URL（/exec）
      <input id="cfgUrl" type="url" placeholder="https://script.google.com/macros/s/.../exec">
    </label>
    <label>API Key（未設定でも可）
      <input id="cfgKey" type="text" placeholder="（空でも可）">
    </label>
    <label>音源ベースURL（例: https://example.com/audio または ./audio）
      <input id="cfgAudioBase" type="text" placeholder="./audio">
    </label>
    <div class="row" style="margin-top:8px">
      <button id="btnPickDir" class="btn">音源フォルダを指定（フォルダピッカー）</button>
      <button id="btnClearDir" class="btn">フォルダ解除</button>
      <span id="dirStatus" class="muted" style="font-size:12px"></span>
    </div>
    <div class="row" style="margin-top:8px">
      <input id="filePick" type="file" accept="audio/*" multiple style="display:none">
      <button id="btnImport" class="btn">音源ファイルをOPFSへ取り込み</button>
      <button id="btnTestAudio" class="btn">テスト再生</button>
      <div class="grow"></div>
      <button id="cfgClose" class="btn">閉じる</button>
      <button id="cfgSave" class="btn" style="background:#1a2134;border-color:#233252">保存</button>
    </div>
  </div>
</div>

<script>
(function(){
  // ===== Utilities =====
  const qs=(s,el=document)=>el.querySelector(s);
  const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
  const now=()=>Date.now(); const UA=(()=>navigator.userAgent||'')();
  const norm=s=>(s||'').toLowerCase().normalize('NFKC').replace(/[\p{P}\p{S}]/gu,' ').replace(/\s+/g,' ').trim();
  const toks=s=>norm(s).split(' ').filter(Boolean);
  // 連続重複を圧縮（a a a → a）
  function dedupeRuns(arr){
    const out=[]; for(const w of arr){ if(out.length && out[out.length-1]===w) continue; out.push(w); }
    return out;
  }

  function approxWithin1(a,b){
    if(!a || !b) return false;
    if(a===b) return true;
    const la=a.length, lb=b.length;
    if(Math.abs(la-lb)>1) return false;
    let i=0,j=0,diff=0;
    while(i<la && j<lb){
      if(a[i]===b[j]){ i++; j++; continue; }
      if(++diff>1) return false;
      if(la>lb) i++;
      else if(lb>la) j++;
      else { i++; j++; }
    }
    diff += (la-i) + (lb-j);
    return diff<=1;
  }
  // final 文の“増分”だけを安定テキストに追加
  function appendStableFinal(stable, fragment){
    const A = toks(stable);
    const B = toks(fragment);
    // 語単位LCP
    let k = 0;
    while (k < A.length && k < B.length && A[k] === B[k]) k++;
    // B が A の拡張なら尾部だけ追加。拡張でなければ新規文として結合。
    const merged = (k > 0 || !A.length) ? A.concat(B.slice(k)) : A.concat(B);
    return dedupeRuns(merged).join(' ');
  }
  function spanify(text){
    const parts=(text||'').match(/\S+|\s+/g)||[];
    return parts.map(part=>{
      if(/\s+/.test(part)){
        const converted=part
          .replace(/\r?\n/g,'<br>')
          .replace(/[^\S\r\n]+/g,' ');
        return converted || ' ';
      }
      const clean=part.replace(/[^\p{L}\p{N}'-]/gu,'');
      return `<span class="tok" data-w="${clean}">${part}</span>`;
    }).join('');
  }
  function toast(msg, ms=1500){ const t=qs('#toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none', ms); }

  const LEVEL_KEY='itemLevelV1';
  function loadLevelState(){ try{ return JSON.parse(localStorage.getItem(LEVEL_KEY)||'{}'); }catch(_){ return {}; } }
  function saveLevelState(state){ try{ localStorage.setItem(LEVEL_KEY, JSON.stringify(state)); }catch(_){ } }
  let LEVEL_STATE=loadLevelState();
  function evaluateLevel(matchRate, hintStageUsed){
    const rate=Math.max(0, Math.min(1, matchRate||0));
    if(rate < 0.70) return 1;
    if(rate < 0.90) return 2;
    if((hintStageUsed||0) <= 0){
      return rate>=0.999 ? 5 : 4;
    }
    return 3;
  }
  function getLevelInfo(id){
    if(!id) return {best:1,last:1};
    return LEVEL_STATE[id] || {best:1,last:1};
  }
  function updateLevelInfo(id, levelCandidate, matchRate, hintStageUsed){
    if(!id) return {best:levelCandidate,last:levelCandidate};
    const info=LEVEL_STATE[id] || {best:1,last:1};
    info.last = levelCandidate;
    if(levelCandidate > (info.best||1)) info.best = levelCandidate;
    info.lastMatch = +(matchRate||0);
    info.hintStage = hintStageUsed;
    info.updatedAt = Date.now();
    LEVEL_STATE[id]=info;
    saveLevelState(LEVEL_STATE);
    return info;
  }
  function refreshLevelDisplay(info){
    if(!el.level) return;
    if(!info){ el.level.textContent='—'; return; }
    const last = info.last || info.best || 1;
    const best = info.best || last;
    el.level.textContent = best>last ? `${last} / ${best}` : `${last}`;
  }

  const WORD_STATS_KEY='wordStatsV1';
  function loadWordStats(){ try{ return JSON.parse(localStorage.getItem(WORD_STATS_KEY)||'{}'); }catch(_){ return {}; } }
  function saveWordStats(state){ try{ localStorage.setItem(WORD_STATS_KEY, JSON.stringify(state)); }catch(_){ } }
  let WORD_STATS=loadWordStats();
  const FOCUS_WORD_KEY='focusWordV1';
  let focusWord=(localStorage.getItem(FOCUS_WORD_KEY)||'').trim();
  if(!focusWord) focusWord=null;
  function rememberFocusWord(){
    try{
      if(focusWord){ localStorage.setItem(FOCUS_WORD_KEY, focusWord); }
      else{ localStorage.removeItem(FOCUS_WORD_KEY); }
    }catch(_){ }
  }
  function getTopWeakWords(limit=5){
    const arr=[];
    for(const [word,data] of Object.entries(WORD_STATS||{})){
      if(!data || !data.seen) continue;
      const missRate = data.miss ? data.miss / Math.max(1, data.seen) : 0;
      if(data.seen < 2 && missRate <= 0) continue;
      arr.push({ word, missRate, miss:data.miss||0, seen:data.seen||0, updated:data.updatedAt||0 });
    }
    arr.sort((a,b)=>{
      if(b.missRate!==a.missRate) return b.missRate-a.missRate;
      if(b.miss!==a.miss) return b.miss-a.miss;
      if(b.seen!==a.seen) return b.seen-a.seen;
      return (b.updated||0)-(a.updated||0);
    });
    return arr.slice(0, limit);
  }
  function refreshWeakWordBar(){
    if(!el.weak) return;
    el.weak.innerHTML='';
    const top=getTopWeakWords(5);
    const hasFocus = !!focusWord;
    if(!hasFocus && !top.length){
      el.weak.hidden=true;
      return;
    }
    if(hasFocus){
      const chip=document.createElement('span');
      chip.className='word active';
      chip.dataset.word=focusWord;
      chip.dataset.action='clear';
      chip.textContent=`集中:${focusWord}`;
      el.weak.appendChild(chip);
    }
    if(top.length){
      const label=document.createElement('span');
      label.className='label';
      label.textContent='苦手単語';
      el.weak.appendChild(label);
      top.forEach(({word, missRate, miss, seen})=>{
        const chip=document.createElement('span');
        chip.className='word';
        chip.dataset.word=word;
        chip.textContent=`${word} (${Math.round(missRate*100)}%・${miss}/${seen})`;
        el.weak.appendChild(chip);
      });
    }
    el.weak.hidden=false;
  }
  function recordWordPerformance(item, matchInfo){
    if(!item) return;
    const refTokens=toks(item.en||'');
    const misses=new Set((matchInfo?.missing||[]).map(w=>norm(w)));
    const nowTs=Date.now();
    for(const token of refTokens){
      const key=norm(token);
      if(!key) continue;
      const info=WORD_STATS[key] || {seen:0, miss:0};
      info.seen = (info.seen||0)+1;
      if(misses.has(key)){ info.miss = (info.miss||0)+1; }
      info.updatedAt = nowTs;
      WORD_STATS[key]=info;
    }
    saveWordStats(WORD_STATS);
    refreshWeakWordBar();
  }
  function applyFocusWord(word){
    const next=(word||'').trim();
    if(next){
      focusWord=next;
      rememberFocusWord();
      toast(`「${focusWord}」を集中練習に設定しました`);
    }else{
      focusWord=null;
      rememberFocusWord();
      toast('集中練習モードを解除しました');
    }
    rebuildAndRender(true);
    refreshWeakWordBar();
  }

  let toneCtx=null;
  function playTone(type){
    try{
      const AC=window.AudioContext||window.webkitAudioContext;
      if(!AC) return;
      if(!toneCtx){ toneCtx=new AC(); }
      if(toneCtx.state==='suspended'){ toneCtx.resume().catch(()=>{}); }
      const osc=toneCtx.createOscillator();
      const gain=toneCtx.createGain();
      const now=toneCtx.currentTime;
      let freq=440, duration=0.2, peak=0.15;
      if(type==='success'){ freq=880; duration=0.25; peak=0.2; }
      else if(type==='fail'){ freq=300; duration=0.3; peak=0.18; }
      else if(type==='start'){ freq=523.25; duration=0.12; peak=0.12; }
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(peak, now+0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now+duration);
      osc.connect(gain);
      gain.connect(toneCtx.destination);
      osc.start(now);
      osc.stop(now+duration+0.05);
    }catch(_){ }
  }

  // ===== Elements =====
  const el={ left:qs('#statLeft'), min:qs('#statMin'), streak:qs('#statStreak'), pbar:qs('#pbar'), footer:qs('#footerInfo'), en:qs('#enText'), ja:qs('#jaText'), chips:qs('#chips'), weak:qs('#weakWords'), match:qs('#valMatch'), level:qs('#valLevel'), attempt:qs('#attemptInfo'), next:qs('#btnNext'), mic:qs('#btnMic'), card:qs('#card'), secSel:qs('#secSel'), orderSel:qs('#orderSel'), chkWeak:qs('#chkOnlyWeak'), cfgBtn:qs('#btnCfg'), cfgModal:qs('#cfgModal'), cfgUrl:qs('#cfgUrl'), cfgKey:qs('#cfgKey'), cfgAudioBase:qs('#cfgAudioBase'), cfgSave:qs('#cfgSave'), cfgClose:qs('#cfgClose'), btnImport:qs('#btnImport'), filePick:qs('#filePick'), btnTestAudio:qs('#btnTestAudio'), btnPickDir:qs('#btnPickDir'), btnClearDir:qs('#btnClearDir'), dirStatus:qs('#dirStatus') };
  const audio=qs('#player');
  const PREFETCH_POOL=new Map();
  const PREFETCH_LIMIT=6;
  let sessionActive=false;
  let sessionStarting=false;
  let remoteStatus=null;
  let localMinutes=0;
  let localStreak=0;
  let QUEUE=[];
  let idx=-1;
  let sessionStart=0;
  let cardStart=0;

  function updateHeaderStats(){
    const queueLen=Array.isArray(QUEUE)?QUEUE.length:0;
    const leftVal = remoteStatus && remoteStatus.remaining_cards!=null ? Number(remoteStatus.remaining_cards) : queueLen;
    const displayLeft = Number.isFinite(leftVal) ? Math.max(0, Math.round(leftVal)) : queueLen;
    el.left.textContent = displayLeft!=null ? displayLeft : 0;
    if(!remoteStatus && sessionActive && sessionStart){
      localMinutes = Math.max(localMinutes, Math.round((now()-sessionStart)/60000));
    }
    let minVal = localMinutes;
    if(remoteStatus){
      if(remoteStatus.remaining_minutes!=null) minVal = remoteStatus.remaining_minutes;
      else if(remoteStatus.minutes_today!=null) minVal = remoteStatus.minutes_today;
    }
    if(Number.isFinite(minVal)) minVal = Math.max(0, Math.round(minVal));
    el.min.textContent = minVal!=null ? minVal : 0;
    const streakVal = remoteStatus && remoteStatus.streak!=null ? Number(remoteStatus.streak) : localStreak;
    const displayStreak = Number.isFinite(streakVal) ? Math.max(0, Math.round(streakVal)) : 0;
    el.streak.textContent = displayStreak;
  }

  function applyRemoteStatus(status){
    remoteStatus = status ? Object.assign({}, status) : null;
    updateHeaderStats();
  }

  refreshWeakWordBar();
  if(el.weak){
    el.weak.addEventListener('click',(ev)=>{
      const chip=ev.target.closest('.word');
      if(!chip) return;
      const action=chip.dataset.action||'';
      if(action==='clear'){ applyFocusWord(''); return; }
      const word=(chip.dataset.word||'').trim();
      if(!word) return;
      if(focusWord && norm(focusWord)===norm(word)){ applyFocusWord(''); }
      else{ applyFocusWord(word); }
    });
  }

  function waitForAudioReady(el, timeout=2000){
    if(!el) return Promise.resolve();
    if(el.readyState>=2) return Promise.resolve();
    return new Promise(resolve=>{
      let settled=false;
      const finalize=()=>{
        if(settled) return;
        settled=true;
        el.removeEventListener('canplay', onReady);
        el.removeEventListener('canplaythrough', onReady);
        el.removeEventListener('loadeddata', onReady);
        el.removeEventListener('error', onReady);
        clearTimeout(timer);
        resolve();
      };
      const onReady=()=>finalize();
      const timer=setTimeout(()=>finalize(), timeout);
      el.addEventListener('canplay', onReady, {once:true});
      el.addEventListener('canplaythrough', onReady, {once:true});
      el.addEventListener('loadeddata', onReady, {once:true});
      el.addEventListener('error', onReady, {once:true});
    });
  }

  async function setAudioSource(url){
    if(!url){
      clearAudioSource();
      return;
    }
    if(audio.dataset.srcKey !== url){
      audio.dataset.srcKey = url;
      audio.src = url;
    }
    try{ audio.load?.(); }catch(_){ }
    await waitForAudioReady(audio, 2000);
  }

  function clearAudioSource(){
    delete audio.dataset.srcKey;
    audio.removeAttribute('src');
    try{ audio.load?.(); }catch(_){ }
  }

  function rememberPrefetch(url, entry){
    PREFETCH_POOL.set(url, entry);
    if(PREFETCH_POOL.size>PREFETCH_LIMIT){
      const firstKey=PREFETCH_POOL.keys().next().value;
      const old=PREFETCH_POOL.get(firstKey);
      if(old && old.audio){
        try{ old.audio.pause?.(); }catch(_){ }
        old.audio.removeAttribute?.('src');
      }
      PREFETCH_POOL.delete(firstKey);
    }
  }

  const FAIL_LIMIT=3;
  let failCount=0;

  let hintStage=1;
  let maxHintStageUsed=1;
  let currentEnHtml='';
  let currentItem=null;

  function setHintStage(stage,{reset=false}={}){
    const next=Math.max(0, Math.min(2, Number.isFinite(stage)?Math.floor(stage):0));
    const prev=hintStage;
    hintStage=next;
    if(reset){ maxHintStageUsed=next; }
    else if(next>maxHintStageUsed){ maxHintStageUsed=next; }
    if(next<=0){
      el.en.classList.add('concealed');
      el.en.innerHTML='<span class="hint-placeholder">上にスワイプして英文ヒントを表示</span>';
      el.ja.style.display='none';
      clearHighlight();
    }else{
      el.en.classList.remove('concealed');
      el.en.innerHTML=currentEnHtml||'';
      el.ja.style.display = next>=2 ? 'block' : 'none';
      if(currentItem && lastMatchEval && lastMatchEval.source){
        lastMatchEval = matchAndHighlight(currentItem.en, lastMatchEval.source);
        const score=calcMatchScore(lastMatchEval.refCount, lastMatchEval.recall, lastMatchEval.precision);
        updateMatch(score);
      }
    }
    return prev!==next;
  }

  function advanceHintStage(){
    if(!sessionActive) return;
    if(hintStage>=2){ toast('ヒントはすべて表示済みです'); return; }
    const changed=setHintStage(hintStage+1);
    if(changed){
      if(hintStage===1){ el.footer.textContent='英文ヒントを表示しました。もう一度で和訳ヒント。'; }
      else if(hintStage===2){ el.footer.textContent='和訳ヒントを表示しました'; }
    }
  }

  function updateMatch(rate){
    el.match.classList.remove('match-good','match-mid','match-bad');
    if(rate==null || !isFinite(rate)){
      el.match.textContent='—';
      return;
    }
    const pct=Math.max(0, Math.min(100, Math.round(rate*100)));
    el.match.textContent=`${pct}%`;
    if(pct>=85){ el.match.classList.add('match-good'); }
    else if(pct>=70){ el.match.classList.add('match-mid'); }
    else { el.match.classList.add('match-bad'); }
  }

  function updateAttemptInfo(){
    if(failCount<=0){ el.attempt.textContent=''; el.attempt.classList.remove('alert'); return; }
    const remain=Math.max(0, FAIL_LIMIT-failCount);
    el.attempt.textContent = remain>0 ? `リトライ残り ${remain}回` : '規定回数に達しました';
    if(remain<=1){ el.attempt.classList.add('alert'); }
    else{ el.attempt.classList.remove('alert'); }
  }

  function hideNextCta(){
    el.next.hidden=true;
    el.next.disabled=true;
    el.mic.disabled=false;
  }

  function showNextCta(){
    el.next.hidden=false;
    el.next.disabled=false;
    el.mic.disabled=true;
  }

  function setMicState(on){
    el.mic.classList.toggle('recording', !!on);
  }

  function calcMatchScore(refCount, recall, precision){
    if(!refCount) return 1;
    if((recall+precision)<=0) return 0;
    return (2*recall*precision)/(recall+precision);
  }

  // ===== Config =====
  const CFG_KEY='appConfigV3';
  function loadCfg(){ try{return JSON.parse(localStorage.getItem(CFG_KEY)||'{}')}catch(_){return{}} }
  function saveCfg(o){ localStorage.setItem(CFG_KEY, JSON.stringify(o)); }
  let CFG=Object.assign({ apiUrl:'', apiKey:'', audioBase:'./audio' }, loadCfg());

  const PENDING_KEY='pendingLogsV1';
  function loadPendingLogs(){
    try{
      const raw=JSON.parse(localStorage.getItem(PENDING_KEY)||'[]');
      if(Array.isArray(raw)) return raw.filter(entry=>entry&&entry.type&&entry.url);
    }catch(_){ }
    return [];
  }
  let PENDING_LOGS=loadPendingLogs();
  for(const entry of PENDING_LOGS){
    if(!entry.uid) entry.uid=generateUid();
    if(entry.data && !entry.data.client_uid) entry.data.client_uid=entry.uid;
  }
  rememberPending();
  function rememberPending(){ try{ localStorage.setItem(PENDING_KEY, JSON.stringify(PENDING_LOGS)); }catch(_){ } }
  function generateUid(){ if(window.crypto?.randomUUID){ try{ return crypto.randomUUID(); }catch(_){ } } return 'uid-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2); }
  let flushPromise=null;
  async function flushPendingLogs(){
    if(!PENDING_LOGS.length) return;
    if(flushPromise) return flushPromise;
    flushPromise=(async()=>{
      const accepted=new Set();
      const groups=new Map();
      for(const entry of PENDING_LOGS){
        if(!entry || !entry.url || !entry.type) continue;
        const key=`${entry.url}::${entry.apiKey||''}`;
        if(!groups.has(key)) groups.set(key,{url:entry.url, apiKey:entry.apiKey, items:[]});
        const data=Object.assign({}, entry.data||{});
        if(!data.client_uid) data.client_uid=entry.uid;
        groups.get(key).items.push({uid:entry.uid, type:entry.type, data});
      }
      for(const group of groups.values()){
        if(!group.items.length) continue;
        const payload={type:'bulk', apiKey:group.apiKey, entries:group.items};
        try{
          const res=await fetch(group.url,{method:'POST',headers:{'Content-Type':'text/plain;charset=UTF-8'},body:JSON.stringify(payload)});
          if(!res.ok) continue;
          let json=null;
          try{ json=await res.json(); }catch(_){ }
          if(json && json.ok){
            const ack=Array.isArray(json.accepted)?json.accepted:group.items.map(it=>it.uid);
            ack.forEach(uid=>accepted.add(uid));
          }
        }catch(err){ console.warn('flushPendingLogs', err); }
      }
      let changed=false;
      if(accepted.size){
        PENDING_LOGS=PENDING_LOGS.filter(entry=>!accepted.has(entry.uid));
        changed=true;
      }
      const cleaned=PENDING_LOGS.filter(entry=>entry && entry.url);
      if(cleaned.length!==PENDING_LOGS.length){
        PENDING_LOGS=cleaned;
        changed=true;
      }
      if(changed) rememberPending();
    })();
    try{
      await flushPromise;
    }finally{
      flushPromise=null;
    }
  }

  async function sendLog(type,data){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return;
    const uid=generateUid();
    const payload=Object.assign({}, data||{});
    if(!payload.client_uid) payload.client_uid=uid;
    const entry={ uid, type, data:payload, url, apiKey:(CFG.apiKey||'')||undefined, createdAt:Date.now() };
    PENDING_LOGS.push(entry);
    rememberPending();
    try{ await flushPendingLogs(); }catch(err){ console.warn('sendLog', err); }
  }

  // ===== IndexedDB for DirectoryHandle =====
  const DB='fs-handles', STORE='dir';
  function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
  async function saveDirHandle(h){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(h,'audio'); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
  async function loadDirHandle(){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const rq=tx.objectStore(STORE).get('audio'); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
  async function clearDirHandle(){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).delete('audio'); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }

  let DIR=null; // FileSystemDirectoryHandle
  async function ensureDir(){ if(DIR) return DIR; try{ DIR = await loadDirHandle(); if(!DIR) return null; const q = await DIR.queryPermission?.({mode:'read'}) || 'granted'; if(q!=='granted'){ const r = await DIR.requestPermission?.({mode:'read'}); if(r!=='granted'){ DIR=null; return null; } } return DIR; }catch(_){ DIR=null; return null; } }

  // Settings modal
  if(el.cfgBtn && el.cfgModal && el.cfgUrl && el.cfgKey && el.cfgAudioBase){
    el.cfgBtn.addEventListener('click', ()=>{
      el.cfgUrl.value=CFG.apiUrl||'';
      el.cfgKey.value=CFG.apiKey||'';
      el.cfgAudioBase.value=CFG.audioBase||'./audio';
      refreshDirStatus();
      el.cfgModal.style.display='flex';
    });
  }
  if(el.cfgClose && el.cfgModal){
    el.cfgClose.addEventListener('click', ()=>{ el.cfgModal.style.display='none'; });
  }
  if(el.cfgSave && el.cfgModal && el.cfgUrl && el.cfgKey && el.cfgAudioBase){
    el.cfgSave.addEventListener('click', ()=>{
      CFG.apiUrl=(el.cfgUrl.value||'').trim();
      CFG.apiKey=(el.cfgKey.value||'').trim();
      CFG.audioBase=(el.cfgAudioBase.value||'').trim()||'./audio';
      saveCfg(CFG);
      if((CFG.apiUrl||'').trim()){
        for(const entry of PENDING_LOGS){
          entry.url=CFG.apiUrl.trim();
          entry.apiKey=(CFG.apiKey||'')||undefined;
        }
      } else {
        for(const entry of PENDING_LOGS){
          entry.url='';
          entry.apiKey=undefined;
        }
        applyRemoteStatus(null);
      }
      rememberPending();
      el.cfgModal.style.display='none';
      toast('設定を保存しました');
      if((CFG.apiUrl||'').trim()){
        syncProgressAndStatus().catch(()=>{});
      }
    });
  }
  if(el.btnPickDir){
    el.btnPickDir.addEventListener('click', async()=>{
      if(!window.showDirectoryPicker){ toast('この端末はフォルダピッカー非対応'); return; }
      try{
        const h=await showDirectoryPicker({mode:'read'});
        await saveDirHandle(h);
        DIR=h;
        refreshDirStatus();
        toast('フォルダを保存しました');
      }catch(e){
        if(e&&e.name!=='AbortError') toast('フォルダ選択に失敗');
      }
    });
  }
  if(el.btnClearDir){
    el.btnClearDir.addEventListener('click', async()=>{
      await clearDirHandle();
      DIR=null;
      refreshDirStatus();
      toast('フォルダ設定を解除');
    });
  }
  function refreshDirStatus(){ if(!el.dirStatus) return; el.dirStatus.textContent = DIR? '保存済み':'未設定'; }

  // Import audio (OPFS)
  if(el.btnImport && el.filePick){
    el.btnImport.addEventListener('click', ()=>{ el.filePick.click(); });
    el.filePick.addEventListener('change', async(ev)=>{
      const files=[...ev.target.files||[]];
      if(!files.length){ toast('ファイル未選択'); return; }
      try{
        if(!(navigator.storage&&navigator.storage.getDirectory)) throw new Error('OPFS未対応');
        const root=await navigator.storage.getDirectory();
        let ok=0;
        for(const f of files){
          const fh=await root.getFileHandle(f.name,{create:true});
          const w=await fh.createWritable();
          await w.write(f);
          await w.close();
          ok++;
        }
        toast(`${ok} 件をOPFSへ保存`);
      }catch(e){
        console.error(e);
        toast('OPFS取り込み失敗');
      }
    });
  }

  // GAS Bridge
  async function refreshRemoteStatus(){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return null;
    try{
      const payload={type:'status', apiKey:CFG.apiKey||undefined};
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'text/plain;charset=UTF-8'},body:JSON.stringify(payload)});
      if(!res.ok) throw new Error('status '+res.status);
      const json=await res.json();
      if(json && json.ok && json.status){
        applyRemoteStatus(json.status);
        return json.status;
      }
    }catch(err){ console.warn('refreshRemoteStatus', err); }
    return null;
  }

  async function syncProgressAndStatus(){
    const url=(CFG.apiUrl||'').trim();
    if(!url) return null;
    try{ await flushPendingLogs(); }catch(err){ console.warn('syncProgressAndStatus', err); }
    return refreshRemoteStatus();
  }

  window.addEventListener('online', ()=>{
    flushPendingLogs().then(()=>refreshRemoteStatus()).catch(()=>{});
  });

  // Data
  const DATA_URL='./data/items.json';
  async function fetchJson(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(url+': '+r.status); return r.json(); }
  window.ALL_ITEMS=[]; let SRS_MAP=new Map();
  async function ensureDataLoaded(){ if(!window.ALL_ITEMS.length){ window.ALL_ITEMS=await fetchJson(DATA_URL); } if(!SRS_MAP.size){ try{ const arr=await fetchJson('./data/srs.json'); const m=new Map(); for(const x of arr) m.set(x.id,x); SRS_MAP=m; }catch(_){ SRS_MAP=new Map(); } } }

  // Build section options (All/単一)
  function initSectionPicker(){ const sel=el.secSel; sel.innerHTML=''; sel.appendChild(new Option('全体','')); const units=[...new Set(window.ALL_ITEMS.map(x=>x.unit).filter(Boolean))].sort((a,b)=>{const na=+String(a).replace(/\D+/g,'')||0, nb=+String(b).replace(/\D+/g,'')||0; return na-nb||String(a).localeCompare(String(b));}); for(const u of units){ sel.appendChild(new Option(u,u)); } const saved=localStorage.getItem('secSel')||''; sel.value=saved; sel.onchange=()=>{ localStorage.setItem('secSel', sel.value); rebuildAndRender(true); };
    const ordSaved=localStorage.getItem('orderSel')||'asc'; el.orderSel.value=ordSaved; el.orderSel.onchange=()=>{ localStorage.setItem('orderSel', el.orderSel.value); rebuildAndRender(true); };
    el.chkWeak.checked = localStorage.getItem('onlyWeak')==='1'; el.chkWeak.onchange=()=>{ localStorage.setItem('onlyWeak', el.chkWeak.checked?'1':'0'); rebuildAndRender(true); };
  }

  function isUnlearned(id){ const info=getLevelInfo(id); if((info.best||1)<3) return true; const s=SRS_MAP.get(id); if(!s) return true; if(s.last_result===0) return true; if((s.ease||0)<2.0 && (s.interval_d||0)<3) return true; return false; }
  function buildQueue(){ const sec=el.secSel.value; const order=el.orderSel.value; const onlyWeak=el.chkWeak.checked; let items=(sec?'filter':'all')==='all' ? window.ALL_ITEMS : window.ALL_ITEMS.filter(x=>String(x.unit)===sec); if(onlyWeak) items=items.filter(x=>isUnlearned(x.id)); if(focusWord){ const w=norm(focusWord); if(w) items=items.filter(x=>norm(x.en).includes(w)); } if(order==='rnd'){ const seed=Math.floor(Date.now()/86400000); let t=seed>>>0; const rnd=()=>{t^=t<<13; t^=t>>>17; t^=t<<5; return (t>>>0)/4294967296}; items=items.slice(); for(let i=items.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [items[i],items[j]]=[items[j]],items[i]; } } else { items=items.slice().sort((a,b)=>{ const na=+String(a.unit||'').replace(/\D+/g,'')||0, nb=+String(b.unit||'').replace(/\D+/g,'')||0; if(na!==nb) return na-nb; return String(a.id).localeCompare(String(b.id)); }); } return items.filter(Boolean).map(it=>({ id:it.id,en:it.en,ja:it.ja,tags:it.tags||'',chunks_json:it.chunks||'[]',audio_fn:it.audio_fn||'' })); }

  // Audio resolve: DIR (folder) -> OPFS -> base URL
  const audioUrlCache=new Map();
  async function resolveFromDir(name){ try{ const d=await ensureDir(); if(!d||!name) return ''; const fh=await d.getFileHandle(name).catch(()=>null); if(!fh) return ''; const f=await fh.getFile(); return URL.createObjectURL(f); }catch(_){ return ''; } }
  async function resolveFromOPFS(name){ if(!name) return ''; try{ if(!(navigator.storage&&navigator.storage.getDirectory)) return ''; const root=await navigator.storage.getDirectory(); const fh=await root.getFileHandle(name).catch(()=>null); if(!fh) return ''; const file=await fh.getFile(); return URL.createObjectURL(file); }catch(_){ return ''; } }
  async function resolveAudioUrl(name){ if(!name) return ''; if(audioUrlCache.has(name)) return audioUrlCache.get(name); let url=await resolveFromDir(name); if(!url) url=await resolveFromOPFS(name); if(!url){ const base=(CFG.audioBase||'./audio').replace(/\/$/,''); url= base + '/' + encodeURI(name); } audioUrlCache.set(name,url); return url; }

  async function primeAudio(item){
    if(!item||!item.audio_fn) return;
    const url=await resolveAudioUrl(item.audio_fn);
    if(!url) return;
    if(PREFETCH_POOL.has(url)) return PREFETCH_POOL.get(url).promise;
    const prefetch=new Audio();
    prefetch.preload='auto';
    prefetch.crossOrigin='anonymous';
    prefetch.src=url;
    const promise=waitForAudioReady(prefetch, 4000).finally(()=>{
      try{ prefetch.pause?.(); }catch(_){ }
    });
    try{ prefetch.load?.(); }catch(_){ }
    rememberPrefetch(url,{audio:prefetch,promise});
    return promise;
  }

  // Render & navigation
  function stopAudio(){ try{audio.pause();}catch(_){ } audio.currentTime=0; }
  function resetResult(){ updateMatch(null); }
  function resetTranscript(){ qs('#transcript').innerHTML=''; }
  function toggleJA(){ advanceHintStage(); }

  function showIdleCard(){
    sessionActive=false;
    sessionStarting=false;
    stopAudio();
    clearAudioSource();
    el.en.textContent = QUEUE.length ? 'タップして開始（音声が自動再生されます）' : '出題できる問題がありません';
    el.en.classList.remove('concealed');
    clearHighlight();
    el.ja.textContent = '—';
    el.ja.style.display = 'none';
    el.chips.innerHTML = '';
    currentItem=null;
    currentEnHtml='';
    hintStage=1;
    maxHintStageUsed=1;
    refreshLevelDisplay(null);
    cardStart = now();
    sessionStart = 0;
    failCount = 0;
    resetResult();
    resetTranscript();
    updateAttemptInfo();
    hideNextCta();
    setMicState(false);
    el.mic.disabled = true;
    el.next.hidden = true;
    el.pbar.value = 0;
    el.footer.textContent = QUEUE.length ? '問題部分をタップすると第1問が始まります' : 'キューが空です';
    if(!remoteStatus){
      localMinutes=0;
    }
    updateHeaderStats();
  }

  async function render(i, autoPlay=false){
    stopAudio();
    const it=QUEUE[i];
    if(!it){
      el.footer.textContent='キューが空です';
      clearAudioSource();
      return;
    }
    currentItem=it;
    currentEnHtml=spanify(it.en);
    el.en.classList.remove('concealed');
    el.en.innerHTML=currentEnHtml;
    clearHighlight();
    el.ja.textContent=it.ja;
    el.chips.innerHTML='';
    (it.tags||'').split(',').filter(Boolean).forEach(t=>{ const s=document.createElement('span'); s.className='chip'; s.textContent=t.trim(); el.chips.appendChild(s); });
    const levelInfo=getLevelInfo(it.id);
    refreshLevelDisplay(levelInfo);
    setHintStage(0,{reset:true});
    const url=await resolveAudioUrl(it.audio_fn);
    if(url){
      await setAudioSource(url);
    }else{
      clearAudioSource();
    }
    cardStart=now();
    resetResult();
    resetTranscript();
    lastMatchEval=null;
    failCount=0;
    updateAttemptInfo();
    hideNextCta();
    setMicState(false);
    el.mic.disabled=false;
    primeAudio(QUEUE[i+1]);
    primeAudio(QUEUE[i-1]);
    if(autoPlay&&url){ try{ await audio.play(); }catch(_){ } }
  }

  async function rebuildAndRender(resetIndex=false){
    QUEUE=buildQueue();
    el.pbar.max=Math.max(1, QUEUE.length);
    updateHeaderStats();
    hideNextCta();
    if(resetIndex){
      idx=-1;
      showIdleCard();
      return;
    }
    if(!sessionActive){
      showIdleCard();
      return;
    }
    if(!QUEUE.length){
      showIdleCard();
      return;
    }
    idx=Math.max(0, Math.min(idx, QUEUE.length-1));
    render(idx,false);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
  }

  function advanceToNextSection(){
    if(!el.secSel) return false;
    const options=[...el.secSel.options];
    if(!options.length) return false;
    const currentValue=el.secSel.value;
    const currentIndex=options.findIndex(opt=>opt.value===currentValue);
    if(currentIndex<0 || currentIndex>=options.length-1) return false;
    if(currentIndex===0 && currentValue==='') return false;
    const nextOpt=options[currentIndex+1];
    const nextValue=nextOpt.value;
    el.secSel.value=nextValue;
    localStorage.setItem('secSel', nextValue);
    hideNextCta();
    const label=nextOpt.textContent||nextOpt.label||nextValue||'次のセクション';
    toast(`セクション「${label}」へ進みます`);
    rebuildAndRender(true)
      .then(()=>{
        if(QUEUE.length){
          startSession(true);
        }else{
          el.footer.textContent='次のセクションに出題がありません';
        }
      })
      .catch(err=>{ console.error(err); toast('次のセクションの読み込みに失敗しました'); });
    return true;
  }

  function nextCard(first=false, autoPlay=false){
    if(!QUEUE.length){ el.footer.textContent='キューが空です'; clearAudioSource(); stopAudio(); return; }
    if(!sessionActive) return;
    if(!first && idx>=QUEUE.length-1){
      if(advanceToNextSection()) return;
      toast('最後のセクションまで完了しました');
      return;
    }
    idx = first? 0 : Math.min(QUEUE.length-1, idx+1);
    render(idx, autoPlay);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
  }
  function prevCard(autoPlay=false){
    if(!QUEUE.length) return;
    if(!sessionActive) return;
    idx=Math.max(0, idx-1);
    render(idx, autoPlay);
    el.pbar.value=idx;
    el.footer.textContent=`#${idx+1}/${QUEUE.length}`;
  }

  async function startSession(autoPlay=true){
    if(sessionActive || sessionStarting) return;
    if(!QUEUE.length){ showIdleCard(); return; }
    sessionStarting=true;
    try{
      if((CFG.apiUrl||'').trim()){
        try{ await syncProgressAndStatus(); }catch(err){ console.warn('startSession status', err); }
      }
      await ensureDir();
      sessionActive=true;
      sessionStart=now();
      idx=-1;
      el.mic.disabled=false;
      nextCard(true, autoPlay);
    }finally{
      sessionStarting=false;
    }
  }

  // Gestures
  let touchStart=null; const TH=60;
  el.card.addEventListener('touchstart',(ev)=>{ if(!sessionActive){ touchStart=null; return; } if(ev.touches?.length!==1) return; const t=ev.touches[0]; touchStart={x:t.clientX,y:t.clientY}; },{passive:true});
  el.card.addEventListener('touchend',(ev)=>{ if(!touchStart) return; if(!sessionActive){ touchStart=null; return; } const end=ev.changedTouches[0]; const dx=end.clientX-touchStart.x, dy=end.clientY-touchStart.y; if(Math.abs(dx)>Math.abs(dy) && Math.abs(dx)>TH){ if(dx>0) prevCard(true); else nextCard(false,true); } else if(Math.abs(dy)>TH && dy<0){ toggleJA(); } touchStart=null; },{passive:true});
  el.en.addEventListener('click', async ()=>{ if(!sessionActive){ await startSession(true); return; } if(!audio.src) return; try{ if(audio.paused) await audio.play(); else audio.pause(); }catch(_){ } });
  el.en.addEventListener('dblclick', ()=>{ if(!sessionActive) return; toggleJA(); });
  el.next.onclick=()=> nextCard(false,true);

  // ASR（改良：重複抑制・上限・多重一致防止）
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recog=null, recogOn=false;
  let stableText=''; // 確定テキスト（評価はこちらのみ使用）
  let lastMatchEval=null;

  function clearHighlight(){
    document.querySelectorAll('.en .tok').forEach(sp=>{
      sp.classList.remove('hit');
      sp.classList.remove('miss');
    });
  }

  function matchAndHighlight(refText, hypText){
    const refTokens = toks(refText);
    const hypTokensRaw = toks(hypText);
    const hypTokens = dedupeRuns(hypTokensRaw);

    function evaluateWindow(tokens){
      const remain=new Map();
      const matchedCounts=new Map();
      const matchedWords=[];
      for(const w of refTokens){ remain.set(w, (remain.get(w)||0)+1); }
      tokens.forEach((h,idx)=>{
        if(!h) return;
        let matchKey='';
        if(remain.get(h)>0){ matchKey=h; }
        else{
          for(const [k,c] of remain){ if(c>0 && approxWithin1(k,h)){ matchKey=k; break; } }
        }
        if(matchKey){
          remain.set(matchKey, remain.get(matchKey)-1);
          matchedCounts.set(matchKey, (matchedCounts.get(matchKey)||0)+1);
          matchedWords.push(matchKey);
        }
      });
      const missing=[];
      for(const [w,c] of remain){ for(let i=0;i<(c||0);i++) missing.push(w); }
      const matchedCount=matchedWords.length;
      const recall = refTokens.length? matchedCount/refTokens.length : 1;
      const precision = tokens.length? matchedCount/tokens.length : 1;
      return {tokens, recall, precision, missing, matchedWords, matchedCount, matchedCounts};
    }

    function cloneCountMap(map){
      const out=new Map();
      if(map){ for(const [k,v] of map) out.set(k,v); }
      return out;
    }

    let best=evaluateWindow(hypTokens);
    best.start=0; best.end=hypTokens.length;
    const refLen=refTokens.length;
    const slack = Math.max(4, Math.ceil(refLen*0.5));
    const minLen = Math.max(1, refLen ? Math.max(1, refLen - slack) : 1);
    const maxLen = Math.max(
      minLen,
      Math.min(hypTokens.length, Math.max(refLen + slack, refLen * 2 || 1))
    );
    for(let start=0; start<hypTokens.length; start++){
      for(let len=minLen; len<=maxLen; len++){
        const end=start+len;
        if(end>hypTokens.length) break;
        const slice=hypTokens.slice(start,end);
        const evalRes=evaluateWindow(slice);
        evalRes.start=start; evalRes.end=end;
        const bestScore=calcMatchScore(refLen, best.recall, best.precision);
        const candScore=calcMatchScore(refLen, evalRes.recall, evalRes.precision);
        if(candScore>bestScore || (candScore===bestScore && (
          evalRes.recall>best.recall || (evalRes.recall===best.recall && (
            evalRes.precision>best.precision || (evalRes.precision===best.precision && (
              Math.abs((evalRes.tokens?.length||0)-refLen) < Math.abs((best.tokens?.length||0)-refLen) || (
                Math.abs((evalRes.tokens?.length||0)-refLen) === Math.abs((best.tokens?.length||0)-refLen) && (evalRes.start||0)<=(best.start||0)
              )
            ))
          ))
        ))){
          best=evalRes;
        }
      }
    }

    const spans=[...document.querySelectorAll('.en .tok')].filter(s=>s.dataset.w);
    const matchMap=cloneCountMap(best.matchedCounts);
    for(const sp of spans){
      const w=norm(sp.dataset.w);
      if(!w){ sp.classList.remove('hit'); sp.classList.add('miss'); continue; }
      let hit=false;
      if(matchMap.get(w)>0){
        hit=true;
        matchMap.set(w, matchMap.get(w)-1);
      }else{
        for(const [k,c] of matchMap){
          if(c>0 && approxWithin1(k,w)){
            hit=true;
            matchMap.set(k, c-1);
            break;
          }
        }
      }
      sp.classList.toggle('hit', hit);
      sp.classList.toggle('miss', !hit);
    }

    return {
      recall: best.recall,
      precision: best.precision,
      matched: best.matchedWords,
      missing: best.missing,
      refCount: refLen,
      hypTokens: best.tokens,
      transcript: (best.tokens||[]).join(' '),
      source: (hypText||'').trim()
    };
  }

  function showTranscriptInterim(text){ qs('#transcript').innerHTML=`<span class="interim">${text}</span>`; }
  function showTranscriptFinal(text){ qs('#transcript').textContent=text; }

  function startRec(){
    if(!SR){ toast('この端末では音声認識が使えません'); return; }
    if(el.mic.disabled) return;
    if(recogOn) return;
    hideNextCta();
    const shouldResume = audio && !audio.paused;
    recog = new SR();
    recog.lang = 'en-US';
    recog.continuous = true;
    recog.interimResults = true;
    recog.maxAlternatives = 1;

    stableText = '';
    lastMatchEval=null;
    recogOn = true;
    setMicState(true);
    playTone('start');
    resetTranscript();
    clearHighlight();

    try{ recog.start(); }catch(_){ }

    if(shouldResume && audio?.src){
      audio.play().catch(()=>{});
    }

    recog.onresult = (ev)=>{
      let interim = '';
      for(let i=ev.resultIndex; i<ev.results.length; i++){
        const r = ev.results[i];
        const t = r[0].transcript || '';
        if(r.isFinal){
          // 尾部のみ追加していく
          stableText = appendStableFinal(stableText, t);
          showTranscriptFinal(stableText);
          const trimmedStable = stableText.trim();
          const refItem = QUEUE[idx];
          const refText = refItem ? refItem.en : el.en.textContent;
          const m = matchAndHighlight(refText, trimmedStable);
          lastMatchEval = m;
          const score = calcMatchScore(m.refCount, m.recall, m.precision);
          updateMatch(score);
        }else{
          interim = t;
        }
      }
      if(interim) showTranscriptInterim(interim); // 画面表示だけ・評価には使わない
    };

    recog.onerror = (e)=>{ console.warn(e); toast('ASRエラー: '+(e && e.error || '')); playTone('fail'); setMicState(false); recogOn=false; el.mic.disabled=false; recog=null; };
    recog.onend = ()=>{ if(recogOn) stopRec(); else setMicState(false); };
  }

  async function stopRec(){
    if(!recogOn) return;
    recogOn=false;
    try{ recog && recog.stop && recog.stop(); }catch(_){ }
    setMicState(false);

    const it = QUEUE[idx]; if(!it) return;
    const hyp = stableText.trim();
    const refItem = QUEUE[idx];
    const refText = refItem ? refItem.en : el.en.textContent;
    const matchInfo = (lastMatchEval && lastMatchEval.source === hyp) ? lastMatchEval : matchAndHighlight(refText, hyp);
    lastMatchEval = matchInfo;
    const { recall, precision, matched, missing, refCount, hypTokens, transcript } = matchInfo;
    const matchRate = calcMatchScore(refCount, recall, precision);
    updateMatch(matchRate);

    const stageUsed = maxHintStageUsed;
    const levelCandidate = evaluateLevel(matchRate, stageUsed);
    const levelInfo = updateLevelInfo(it.id, levelCandidate, matchRate, stageUsed);
    refreshLevelDisplay(levelInfo);
    recordWordPerformance(it, matchInfo);

    const pct=Math.max(0, Math.round((matchRate||0)*100));
    const levelLabel = levelInfo ? `Lv${levelInfo.last || levelInfo.best || levelCandidate}` : `Lv${levelCandidate}`;
    const bestLabel = levelInfo && levelInfo.best>levelInfo.last ? ` (最高${levelInfo.best})` : '';

    const pass = matchRate >= 0.70;
    if(pass){
      failCount=0;
      playTone('success');
      showNextCta();
      el.footer.textContent = `一致率${pct}% ${levelLabel}${bestLabel}！「次へ」で進みましょう`;
      if(levelCandidate>=4 && stageUsed<=0){
        toast(`素晴らしい！${levelLabel}達成`, 1600);
      }else{
        toast('Great! 合格です', 1600);
      }
    }else{
      failCount++;
      playTone('fail');
      if(failCount>=FAIL_LIMIT){
        el.footer.textContent = `3回失敗。${levelLabel}で次へ進みます`;
        toast('不合格で次へ進みます', 1600);
        el.mic.disabled=true;
        setTimeout(()=>{ hideNextCta(); nextCard(false,true); }, 900);
      }else{
        el.footer.textContent = `一致率${pct}%：${levelLabel}${bestLabel} 維持のため再挑戦 (${failCount}/${FAIL_LIMIT})`;
        toast('70%未満。もう一度チャレンジ！', 1600);
      }
    }
    updateAttemptInfo();

    const payload = {
      ts: new Date().toISOString(), id: it.id, mode: 'read',
      wer: +(1-recall).toFixed(3), cer: +(1-precision).toFixed(3),
      latency_ms: 0,
      words_spoken: (hypTokens||toks(hyp)).length,
      transcript: transcript || hyp,
      transcript_raw: hyp,
      matched_tokens_json: JSON.stringify(matched),
      missing_tokens_json: JSON.stringify(missing),
      recall:+recall.toFixed(3), precision:+precision.toFixed(3),
      match:+(matchRate||0).toFixed(3),
      hint_stage:stageUsed,
      level_last:levelInfo?.last ?? levelCandidate,
      level_best:levelInfo?.best ?? levelCandidate
    };
    try{ await sendLog('speech', payload); }catch(_){ }
    if(!pass && failCount<FAIL_LIMIT){ el.mic.disabled=false; }
    recog=null;
  }

  el.mic.onclick=()=>{ if(!recogOn) startRec(); else stopRec(); };
  qsa('[data-eval="ok"]').forEach(b=>b.onclick=()=>{ if(!sessionActive) return; submitEval(1); });
  qsa('[data-eval="ng"]').forEach(b=>b.onclick=()=>{ if(!sessionActive) return; submitEval(0); });
  async function submitEval(bin){ const it=QUEUE[idx]; if(!it) return; const payload={ ts:new Date().toISOString(), id:it.id, result:bin, auto_recall:null, auto_precision:null, response_ms:Math.max(0, now()-cardStart), hint_used:(maxHintStageUsed>=2), hint_stage:maxHintStageUsed, hint_en_used:(maxHintStageUsed>=1), device:UA }; try{ await sendLog('attempt', payload); }catch(_){ } hideNextCta(); nextCard(false,true); }

  // Boot
  (async()=>{
    try{
      await ensureDir();
      await ensureDataLoaded();
      updateHeaderStats();
      initSectionPicker();
      refreshDirStatus();
      await rebuildAndRender(true);
      await syncProgressAndStatus();
    }catch(e){
      console.error(e);
      toast('初期化失敗: '+(e&&e.message||e));
    }
  })();
})();
</script>

<!-- ★ Service Worker 登録（最小） -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    });
  }
</script>
</body>
</html>
